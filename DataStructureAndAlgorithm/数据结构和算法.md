2022.8.18开始

# 数据结构

## 第1章、数据结构和算法概述

### 1.1 线性结构和非线性结构



#### 1.1.1 线性结构



**1、线性结构作为最常用的数据结构，其特点是元素之间存在一对一的线性关系**

**2、线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构，顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的**

**3、链式存储的线性表称为链表，链表的存储单元不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息**

**4、线性结构常见的有：数组、队列、链表和栈**





#### 1.1.2 非线性结构



**非线性结构包括：二维数组、多维数组、广义表、树结构、图结构**





## 第2章、稀疏数组和队列



### 2.1稀疏（sparesArray）数组

#### 2.1.1 基本介绍



- 当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组
- 稀疏数组的处理方法是：
  - 记录数组一共有几行几列，有多少个不同值
  - 把具有不同值的元素的行列及值记录在一个小规模的数组中、从而缩小程序的规模
  - 

![image-20220811104759878](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220811104759878.png)



#### 2.1.2 应用场景



![image-20220811105534279](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220811105534279.png)



#### 2.1.3 代码实现



```java
package com.ldm.SparseArray;

/**
 * @author 梁东明
 *点击setting在Editor 的File and Code Templates 修改
 */
public class sparseArray {


        public static void main(String[] args) {
            // TODO Auto-generated method stub
            //创建一个原始的二维数组
            //注意  没有赋值的默认为  0
            int Arr1[][] =new int[6][7];
            Arr1[0][3] = 22;
            Arr1[0][6] = 15;
            Arr1[1][1] = 11;
            Arr1[1][5] = 17;
            Arr1[2][3] = -6;
            Arr1[3][5] = 39;
            Arr1[4][0] = 91;
            Arr1[5][2] = 28;
            System.out.println("原始的二维数组");
            //增强for循环遍历输出原数组
            for (int[] row : Arr1){
                for (int data : row){
                    System.out.print(data+"\t");
                }
                System.out.println();
            }

            //将原始二维数组转换成稀疏数组
            //1、先遍历二维数组，得到非0的数据的个数
            int sum = 0;
            for (int[] row : Arr1) {
                for (int data : row) {
                    if (data != 0){
                        sum ++;
                    }
                }
            }

            //创建对应的稀疏数组
            //count + 1 是为了多记录一条原始数组的大小
            int[][] sparseArr = new int[sum + 1][3];
            //给稀疏数组赋值
            sparseArr[0][0] = 6;
            sparseArr[0][1] = 7;
            sparseArr[0][2] = sum;

            //遍历二维数组，将非0的  值存储在稀疏数组 中
            int count = 0;
            for (int i = 0; i < Arr1.length; i++) {
                for (int j = 0; j < Arr1[i].length; j++) {
                    if (Arr1[i][j] != 0){
                        count ++;
                        sparseArr[count][0] = i;
                        sparseArr[count][1] = j;
                        sparseArr[count][2] = Arr1[i][j];
                    }
                }
            }
            System.out.println();
            //遍历输出稀疏数组
            System.out.println("得到的稀疏数组是");
            for (int i = 0; i < sparseArr.length; i++) {
                System.out.print("\n"+sparseArr[i][0]+"\t"+sparseArr[i][1]+"\t"+sparseArr[i][2]);
            }

            //将稀疏数组还原 原二维数组
            /*
            1、先读取稀疏数组的第一行，根据第一行的信息创建原始数组
            2、再读取稀疏数组的其他行，给原数组的元素赋值
             */
            //1、先读取稀疏数组的第一行，根据第一行的信息创建原始数组
            //注意 sparseArr[0][0] = 6， sparseArr[0][1] = 7；
            //所以下行语句等价于             int Arr2[][] =new int[6]7];
            int Arr2[][] =new int[sparseArr[0][0]][sparseArr[0][1]];


            //2、再读取稀疏数组的其他行，给原数组的元素赋值
            for (int i = 1; i < sparseArr.length; i++) {
                Arr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
            }


            System.out.println();
            System.out.println("恢复后的二维数组");
            for (int[] row : Arr2){
                for (int data : row){
                    System.out.print(data+"\t");
                }
                System.out.println();
            }



        }
}

```



### 2.2 队列



![image-20220813115411092](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220813115411092.png)

#### 2.2.1 基本介绍

- 队列是一个有序列表，可以用数组或是链表来实现

- 遵循先进先出的原则：先入队列的数据先取出
- ![image-20220812212155812](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220812212155812.png)

- 

#### 2.2.2 数组队列代码实现



- 队列本身是有序列表，若用数组的结构来 存储队列的数据，则队列数组的声明如下 其中maxSize是该队列的最大容量



- 因为队列的输出、输入是分别前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变

![image-20220812212835183](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220812212835183.png)

思路分析：

- 将数据存入队列需要处理两个步骤
  - 将尾指针往后移： rear +1 当front=rear【null】
  - 若尾指针rear小于队列的最大下标maxSize-1，则队列没满，这样可以把数据存入rear所指的数组元素，否则无法存入元素

![image-20220812213658281](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220812213658281.png)





```
package com.ldm.queue;

import java.util.Scanner;

/**
 * @author 梁东明
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class ArrayQueueDemo {
    public static void main(String[] args) {

        //创建一个队列对象
        ArrayQueue arrayQueue = new ArrayQueue(4);
        char key = ' '; //接受用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop) {
            System.out.println("a====show you Queue======");
            System.out.println("b=========exit===========");
            System.out.println("c=======add data to Queue");
            System.out.println("d=====get data from Queue");
            System.out.println("e=show the headData in Queue");
            key = scanner.next().charAt(0); //接受一个字符串
            switch (key) {
                case 'a':
                    arrayQueue.showQueue();
                    break;
                case 'b':
                    scanner.close();
                    loop = false;
                    break;
                case 'c':
                    System.out.println("input a number...");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'd':
                    try {
                        int res = arrayQueue.getQueue();
                        System.out.println("取出的数据是= " + res);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    try {
                        int res = arrayQueue.headQueue();
                        System.out.println("res = " + res);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序已退出。。。");
    }
}
//使用数组模拟队列 - 编写一个ArrayQueue类
class ArrayQueue{
    private int maxSize;  //数组最大容量
    private int front;    //队列的队头
    private int rear;    //队列的队尾
    private int[] arr;   //该数组用来存放数据，模拟队列

    //创建队列的构造器
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;  //指向队头的前一个位置
        rear = -1;  //指向队列的尾部的数据（即就是队列的最后一个数据）

    }
    //判断队列为满
    public boolean isFull(){
        return rear == maxSize - 1;
    }
    //判断队列为null
    public boolean isNull(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否为满
        if (isFull()) {
            System.out.println("Queue is full,can't add data");
            return;
        }
        rear ++; //让rear后移
        arr[rear] = n;
    }
    //获取队列的数据  即出队
    public int getQueue(){
        if (isNull()) {
            System.out.println("");
            //return -1;
            //抛出异常
            throw new RuntimeException("sorry, you Queue is null");
        }else {
            front ++; //front后移就能取出数据啦
            return arr[front];
        }
    }
    //显示队列的所有数据
    public void showQueue(){
        //遍历
        if (isNull()) {
            System.out.println("Queue is null,not data");
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
    //显示队列的头数据
    public int headQueue(){
        //判断队列是否为null
        if (isNull()) {
            //return -1;
            //抛出异常
            throw new RuntimeException("sorry, you Queue is null");
        }
        return arr[front+1];
    }

}

```



#### 2.2.3 循环队列（数组结构）

思路分析：

- 队满条件 （rear + 1 + maxSize) % MaxSize == front
- 队空条件  rear == front
- 队实际元素   （rear + maxSize -front

![image-20220812232327308](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220812232327308.png)

- 代码实现



```
package com.ldm.queue;

import java.util.Scanner;

/**
 * @author 梁东明
 * 点击setting在Editor 的File and Code Templates 修改
 */
@SuppressWarnings({"all"})
public class CircleArrayQueueDemo {
    public static void main(String[] args) {

        //创建一个队列对象
        ArrayQueue01 arrayQueue = new ArrayQueue01(4);
        char key = ' '; //接受用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop) {
            System.out.println("a====显示队列======");
            System.out.println("b======退出=======");
            System.out.println("c=====添加数据=====");
            System.out.println("d=====取出数据=====");
            System.out.println("e=====查看队头=====");
            key = scanner.next().charAt(0); //接受一个字符串
            switch (key) {
                case 'a':
                    arrayQueue.showQueue();
                    break;
                case 'b':
                    scanner.close();
                    loop = false;
                    break;
                case 'c':
                    System.out.println("input a number...");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'd':
                    try {
                        int res = arrayQueue.getQueue();
                        System.out.println("取出的数据是= " + res);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    try {
                        int res = arrayQueue.headQueue();
                        System.out.println("res = " + res);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序已退出。。。");
    }
}
//使用数组模拟队列 - 编写一个ArrayQueue类
class ArrayQueue01{
    private int maxSize;  //数组最大容量
    private int front;    //队列的队头
    private int rear;    //队列的队尾
    private int[] arr;   //该数组用来存放数据，模拟队列

    //创建队列的构造器
    public ArrayQueue01(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
    }
    //判断队列为满
    public boolean isFull(){
        return (rear+1)%maxSize == front;
    }
    //判断队列为null
    public boolean isNull(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否为满
        if (isFull()) {
            System.out.println("队列已满，不能添加数据");
            return;
        }
        arr[rear] = n;
        //将rear后移，但是必须考虑取模
        rear = (rear+1)%maxSize;
    }
    //获取队列的数据  即出队
    public int getQueue(){
        if (isNull()) {
            System.out.println("");
            //return -1;
            //抛出异常
            throw new RuntimeException("队列为null，请添加数据");
        }
        //分析front是指向队列的第一个元素
        //1、先把front对应的值保存在一个临时变量
        //将临时保存的变量返回
        int temp = arr[front];
        //将front后移
        front = (front + 1) % maxSize ;
        return temp;


    }
    //显示队列的所有数据
    public void showQueue(){
        //遍历
        if (isNull()) {
            System.out.println("队列为null，请添加数据");
        }
        //先求出当前循环队列有多少个元素再把它们遍历出来
        for (int i = 0; i < front + Size(); i++) {
            System.out.println("第"+(i%maxSize)+"个元素是"+arr[i]);
        }
    }
    //先求出当前循环队列有多少个元素再把它们遍历出来
    public int Size(){

        // 如果不是循环队列当前元素就有 rear-front 个;
        return (rear+maxSize-front) % maxSize;
    }


    //显示队列的头数据
    public int headQueue(){
        //判断队列是否为null
        if (isNull()) {
            //return -1;
            //抛出异常
            throw new RuntimeException("队列为null，请添加数据");
        }
        return arr[front];
    }

}


```



## 第3章 链表

**1、链表是以节点的方式存储**

**2、每个节点包含data域，next域：指向下一个节点**

**3、每个链表的各个节点不一定是连续存储的**

**4、链表可以带头节点和不带头节点的链表**



### 3.1 单链表

#### 3.1.1 增

![image-20220815160006418](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220815160006418.png)



![image-20220815160031559](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220815160031559.png)

#### 3.1.2 删



![image-20220815160137847](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220815160137847.png)

#### 3.1.3 改



![image-20220815160253102](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220815160253102.png)

#### 3.1.4 查

```java

    //遍历单链表，查看链表数据
    public void list(){
        //判断链表为null
        if (head.next == null) {
            System.out.println("链表为null");
            return;
        }
        //因为头节点，不能动，创建一个辅助变量temp
        HeroNode temp = head.next;
        while (true) {
            //判断是否遍历到链表的最后
            if ( temp  == null) {
                return;
            }
            System.out.println(temp);
            //每输出一个元素就把temp后移一位，直到temp.next == null
            temp = temp.next;
        }
    }
```

#### 3.1.5 代码实现

```java
package com.ldm.linkedlist;



/**
 * @author 梁东明
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class SingleLinkedListDemo {

    public static void main(String[] args) {
        //测试
        //先创建节点
        HeroNode hero1 = new HeroNode(1, "ldm", "梁东明");
        HeroNode hero2 = new HeroNode(2, "ldm", "梁东明");
        HeroNode hero3 = new HeroNode(3, "ldm", "梁东明");
        HeroNode hero4 = new HeroNode(4, "ldm", "梁东明");

        //创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
       /*  //添加节点
        singleLinkedList.add(hero1);
        singleLinkedList.add(hero4);
        singleLinkedList.add(hero3);
        singleLinkedList.add(hero2);
        singleLinkedList.list();*/

       //添加节点
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);

      /*  //测试修改节点
        HeroNode newHero = new HeroNode(2, "傻逼", "哈哈");

        singleLinkedList.update(newHero);*/
        singleLinkedList.del(4);
        singleLinkedList.list();


    }
}
//定义单链表，管理节点
class SingleLinkedList{
    //初始化一个头节点，不放任何数据
    private HeroNode head = new HeroNode(0,"","");

   /* //返回头节点
    public HeroNode getHead() {
        return head;
    }*/

    //思路：当不考虑编号
    //1、找到当前链表的最后节点
    //2、将这个最后节点的next指向新的节点

    //尾插法
    public void add(HeroNode heroNode) {

        //因为head节点不能动，因此我们需要一个辅助遍历 temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while(true) {
            //找到链表的最后
            if(temp.next == null) {//
                break;
            }
            //如果没有找到最后, 将将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //将最后这个节点的next 指向 新的节点
        temp.next = heroNode;
    }

    //指定插入
    public void addByOrder(HeroNode heroNode){
        //按指定顺序插入节点
        HeroNode temp = head;
        boolean flag = false;
        //遍历链表
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > heroNode.no){
                break;
            }else if ( temp.next.no == heroNode.no){
                flag = true;   //说明编号已存在 ，不需要插入
            }
            temp = temp.next;  //后移，相当于遍历当前链表
        }
        //判断flag的值
        if (flag) {  //不能插入
            System.out.println("该节点已存在");
        }else {
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    //修改节点，根据no来修改节点
    public void update(HeroNode heroNode){
        //判断节点是否为null
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //定义一个辅助变量
        HeroNode temp = head;
        boolean flag = false;
        //遍历链表
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.no == heroNode.no) {
                flag = true;
                break;
            }
            //后移
            temp = temp.next;
        }
        //
        if (flag) {
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        }else {
            System.out.println("链表上没有该节点，不能修改");
        }

    }
    //删除节点
    public void del(int no){
        //判断节点是否为null
        if ( head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //定义一个辅助变量
        HeroNode temp = head;
        boolean flag = false;
        //遍历链表
        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no == no) {
                flag = true;
                break;
            }
            //后移
            temp = temp.next;
        }
        //
        if (flag) {
           temp.next = temp.next.next;
        }else {
            System.out.println("链表上没有该节点，不能删除");
        }

    }

    //遍历单链表，查看链表数据
    public void list(){
        //判断链表为null
        if (head.next == null) {
            System.out.println("链表为null");
            return;
        }
        //因为头节点，不能动，创建一个辅助变量temp
        HeroNode temp = head.next;
        while (true) {
            //判断是否遍历到链表的最后
            if ( temp  == null) {
                return;
            }
            System.out.println(temp);
            //每输出一个元素就把temp后移一位，直到temp.next == null
            temp = temp.next;
        }
    }

}


//定义node节点
class HeroNode{
    public int no;
    public String  name;
    public String nickname;
    public HeroNode next;

    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }




    //为了方便显示，重写toString方法

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```



### 3.2 单链表的面试题

![image-20220815160545744](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220815160545744.png)

**求单链表节点个数，如果带头节点的链表，则不统计头节点**



```java
 //获取单链表的有效个数
    public void size(){
        HeroNode temp = head;
        int count = 0;
        while (true) {
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
            count ++;
        }
        System.out.println("count = " + count);
    }
```

#### 3.2.1 新浪

**查找单链表中倒数第k个节点**

```java

    //新浪面试题： 打印单链表的倒数第k个节点
    //思路：
    //1、先定义一个k表示倒数第几个节点
    //2、再遍历获取总的链表个数 size
    //3、再用总的个数  size - k 得到第k个元素
    //4、如果找到了就返回，没找打就返回null
    public static HeroNode  findLastReverseNode(HeroNode head,int k){
        //判断链表是否为null
        if ( head.next == null) {
            return null;
        }
        //获取当前链表的总个数size
        int size = getLength(head);
        //第二次遍历，size-reverse位置，就是倒数第k个节点
        if (k <= 0 || k > size) {
            return null;
        }
        //定义一个辅助变量
        HeroNode cur = head.next;
                //遍历cur，直到找到合适的节点

        for (int i = 0; i < (size - k); i++) {
            cur = cur.next;
        }
        return cur;
    }

```

#### 3.2.2 腾讯

**单链表的反转**

思路：

- 先判断当前链表的个数
  - 小于等于一个则不用反转
- 定义一个辅助变量cur==头节点的next
  - Node cur = head.next;
- 定义一个next节点 来指向cur的下一个节点，但是先别赋值
  - Node next = null
- 定义一个反转链表 的头节点，不放任何数据
  - Node reverse  = new Node（0，”“，”“）
- 遍历原来的链表，每遍历一个，将其取出，放在reverse的最前端（头插法）
- 暂时保存当前节点的下一个节点
  - next = cur.next
- 将取出当前的cur放入reverse链表的最前端
  - cur.next = reverse.next
  - reverse.next = cur
  - 如下图两个指针对应上面两行代码





```java
//**单链表的反转**
    public static void  reverseList(HeroNode head){
        //如果当前链表为空，或者只有一个节点，无需反转，直接返回
        if(head.next == null || head.next.next == null) {
            return ;
        }

        //定义一个辅助的指针(变量)，帮助我们遍历原来的链表
        HeroNode cur = head.next;
        HeroNode next = null;// 指向当前节点[cur]的下一个节点
        HeroNode reverseHead = new HeroNode(0, "", "");
        //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
        //动脑筋
        while(cur != null) {
            next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用
            cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端
            reverseHead.next = cur; //将cur 连接到新的链表上
            cur = next;//让cur后移
        }
        //将head.next 指向 reverseHead.next , 实现单链表的反转
        head.next = reverseHead.next;
    }
```

#### 3.2.3 百度

**从尾到头打印单链表：要求1：反向遍历 要求2 ：stack栈**

```java
//从尾到头打印单链表：要求1：反向遍历 要求2 ：stack栈
    //方式2：
    //可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果
    public static void reversePrint(HeroNode head) {
        if(head.next == null) {
            return;//空链表，不能打印
        }
        //创建要给一个栈，将各个节点压入栈
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.next;
        //将链表的所有节点压入栈
        while(cur != null) {
            stack.push(cur);
            cur = cur.next; //cur后移，这样就可以压入下一个节点
        }
        //将栈中的节点进行打印,pop 出栈
        while (stack.size() > 0) {
            System.out.println(stack.pop()); //stack的特点是先进后出
        }
    }
```



### 3.3 双链表

**1、单链表与双链表的优缺点**

- 查找的方向只能是一个方向，而双链表可以向前或者向后查找
- 单链表不能自我删除节点，需要辅助节点，而双链表可以自我删除



![image-20220822131709024](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220822131709024.png)



代码实现：

```java
package com.ldm.linkedlist;

/**
 * @author 梁东明
 * 2022/8/21
 * 86139
 * 单链表使用头插法和尾插法插入节点
 */
public class InsertLinked {
    public static void main(String[] args) {


        //创建节点类对象
        Node1 node1 = new Node1("head", 1);
        Node1 node2 = new Node1("middle", 2);
        Node1 node3 = new Node1("last", 3);
        Node1 node4 = new Node1("lastOne", 4);

        //创建单链表对象
        SingleNode singleNode = new SingleNode();
        /*  尾插法
        singleNode.addLast(node1);
        singleNode.addLast(node2);
        singleNode.addLast(node3);
        singleNode.addLast(node4);
        singleNode.show();
        */
        /* 头插法
        singleNode.addHead(node1);
        singleNode.addHead(node2);
        singleNode.addHead(node3);
        singleNode.addHead(node4);*/

        //指定顺序插入节点
        Node1 order1 = new Node1("head1", 1);
        Node1 order2 = new Node1("middle2", 2);
        Node1 order3 = new Node1("last3", 3);
        Node1 order4 = new Node1("lastOne4", 4);

        singleNode.addByOrder(order4);
        singleNode.addByOrder(order2);
        singleNode.addByOrder(order3);
        singleNode.addByOrder(order1);

        singleNode.show();
    }
}

class SingleNode{

    //初始化头节点，不放任何数据
    private  Node1 head = new Node1("",0);

    //尾插法
    //不管什么插入法，都需要把要插入的节点传入方法中
    public void addLast(Node1 node){
        //定义辅助变量来插入数据
        Node1 temp = head;
        //退出循环
        while (temp.next != null) {
            //遍历到单链表的尾部
            temp = temp.next;
        }
        //退出循环表示找到链表的最后一个节点，就在该节点插入传入的节点
        temp.next = node;
    }

    //判断单链表是否为null
    //单链表头插法
    public void addHead(Node1 node) {
        //如果链表为null，则把传入的第一个元素赋给head.next
        if (head.next == null){
            head.next = node;
            return;
        }
        //如果链表不为null，就定义一个temp来辅助插入节点
        Node1 temp = head.next;
        //把传入的节点插入单链表，注意两个步骤
        //1、head.next  指向    传入的节点
        //2、传入的节点.next  指向  temp
        head.next = node;
        node.next = temp;
    }

    //按照指定顺序插入节点
    public void addByOrder(Node1 node){
        //定义一个辅助变量temp
        Node1 temp = head;
        //定义一个标记，用来寻找 节点 要 插入的位置
        boolean flag = false;
        //遍历链表
        while (true) {
            //如果链表为null就退出循环
            if (temp.next == null) {
                //符合条件 退出循环
                break;
            }
            //比如我插入的节点的编号为4 (node.no==4)，原来temp的后一个节点编号为5 (temp.next.no==5)
            //所以temp后一个节点的就不再指向编号为5的节点，而是指向编号为4的节点（也就是我当前插入的节点）
            //  5 > 4
            if (temp.next.no > node.no){
                //符合条件 退出循环
                break;
            }else if ( temp.next.no == node.no){
                flag = true;   //说明编号已存在 ，不需要插入
                //继续循环遍历，直到找到合适的位置
            }
            temp = temp.next;  //后移，相当于遍历当前链表
        }
        //判断flag的值
        //可以写成flag == true
        if (flag) {  //不能插入
            System.out.println("该节点已存在");
        }else {
            //插入当前节点
            node.next = temp.next;
            temp.next = node;
        }
    }

    //遍历链表，输出链表
    public void show(){
        //判断链表为null
        if (head.next == null) {
            System.out.println("链表为null");
            return;
        }
        //注意这里的链表是不存放节点的，所以和add的方法的遍历有所不同
        Node1 temp = head.next;
        while (temp != null) {
            System.out.println(temp);
            temp = temp.next;
        }
    }
}

class Node1{
    //存放数据
    public String data;
    public int no;


    //指向当前节点的下一个节点，默认为null
    public Node1 next;

    public Node1(String data,int no) {
        this.data = data;
        this.no = no;
    }

    @Override
    public String toString() {
        return "Node{" +
                "name='" + data + '\'' +
                '}';
    }
}

```



### 3.4 环形链表 约瑟夫环



**约瑟夫问题的提出**

![image-20220822161941590](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220822161941590.png) 	

![1](C:\Users\86139\Desktop\1.jpg)



**1、构建一个单向的环形链表思路**

- 先创建第一个节点，让first指向该节点，并形成环形
- 后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表中



**2、遍历环形链表**

- 先让一个辅助变量，指向first节点
- 然后通过一个while循环遍历该环形链表即可



**添加节点的方法**

​                 cur.setNext(node);
​                node.setNext(first);
​                cur = node;
​                //本来cur =  cur.next  来遍历的
​                //但是38行的代码已经让cur.next = node
​                //所以 cur = node  就行了

- 

```java
 //添加节点的方法
    public void addNode(int nums){
        //判断链表是否为null
        if (nums < 1) {
            System.out.println("这是一个空链表");
            return;
        }
        //辅助变量
        Node cur = first;  //先让cur指向first
        //for循环创建链表
        for (int i = 1; i < nums; i++) {
            //根据编号创建节点
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                //私有属性不能通过  first.next = first来赋值
                first.setNext(first); //自己指向自己，循环链表开始雏形
                cur = first;
            }else {
                cur.setNext(node);
                node.setNext(first);
                cur = node;
                //本来cur =  cur.next  来遍历的
                //但是38行的代码已经让cur.next = node
                //所以 cur = node  就行了
            }
        }
    }
```

- 

**遍历节点的方法**

```java
//遍历环形单链表
public void show(){
    //判断链表是否为null
    if (first == null) {
        System.out.println("没有任何节点");
        return;
    }
    //辅助变量
    Node cur = first;
    while (true) {
        System.out.println("节点的编号是："+cur.getNo());
        if (cur.getNext() == first) {
            break;
        }
        cur = cur.getNext();

    }
}
```



**约瑟夫环需要一个辅助变量指向链表的尾巴**

![image-20220823100213810](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220823100213810.png)

**实现代码**

```java
package com.ldm.linkedlist;

/**
 * @author 梁东明
 * 2022/8/22
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class JosepFu {
    public static void main(String[] args) {

        CircleLinkedList circleLinkedList = new CircleLinkedList();
        circleLinkedList.addNode(5);
        circleLinkedList.show();

        //测试出链表是否正确

        circleLinkedList.countNode(3,2,5);
    }
}
//环形链表
class CircleLinkedList{
    //定义头节点,先占着位置，不拉屎。
    private Node first = null;

    //添加节点的方法
    public void addNode(int nums){
        //判断链表是否为null
        if (nums < 1) {
            System.out.println("这是一个空链表");
            return;
        }
        //辅助变量
        Node cur = null;  //先让cur指向first
        //for循环创建链表
        for (int i = 1; i <= nums; i++) {
            //根据编号创建节点
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                //私有属性不能通过  first.next = first来赋值
                first.setNext(first); //自己指向自己，循环链表开始雏形
                cur = first;
            }else {
                cur.setNext(node);
                node.setNext(first);
                cur = node;
                //本来cur =  cur.next  来遍历的
                //但是38行的代码已经让cur.next = node
                //所以 cur = node  就行了
            }
        }
    }
    //遍历环形单链表
    public void show(){
        //判断链表是否为null
        if (first == null) {
            System.out.println("没有任何节点");
            return;
        }
        //辅助变量
        Node cur = first;
        while (true) {
            System.out.println("节点的编号是："+cur.getNo());
            if (cur.getNext() == first) {
                break;
            }
            cur = cur.getNext();

        }
    }

    //根据用户输入，判断节点抛出链表的顺序

    /**
     *
     * @param k      表示从第几个节点开始数数
     * @param m      表示数多少下,数到谁，谁就抛出链表
     * @param nums   表示一开始链表有多少个节点
     */
    public void countNode(int k,int m,int nums){
        //对链表检验
        //这里怕麻烦，就不让nums > k ,否则要取模很麻烦
        if (first == null || k < 1 || k > nums ) {
            System.out.println("参数有误，请重新输入");
            return;
        }
        //创建辅助变量
        Node helper = first;
        //helper应该事先指向环形链表的最后一个节点
        while (true) {
            if (helper.getNext() == first) {//说明helper已经指向最后一个节点
                break;
            }
            helper = helper.getNext();
        }
        //在m开始数数之前，先让helper和first移动 k - 1 次
        for (int i = 0; i < k-1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //m开始数数的时候，让helper和first移动 m - 1 次
        //这样就把数到的那个节点移出链表  这是一个循环操作，直到链表只剩下最后一个节点
        int count = 0;
        while (true) {
            if (helper == first) {  //说明链表只剩下一个节点，跳出循环，该节点获胜
                break;
            }
            //m开始数数的时候，让helper和first移动 m - 1 次
            for (int j = 0; j < m - 1; j++) {
                first = first.getNext();
                helper = helper.getNext();

                count ++;
            }
            //当退出for循环表示第k个节点开始从1开始报数，数到m这个节点，就被淘汰
            //这时，first指向的节点，就是要被淘汰的节点
            //这段是可以输出第几个被淘汰的节点，遗憾的是我不会处理 m为1的情况。所以尽量别用
            System.out.println("第"+(count / (m-1))+"个被淘汰的节点是：" + first.getNo());
            //用这个就没有/ by zero 的异常了。
            //System.out.println("被淘汰的节点是：" + first.getNo());
            //这时候，把first指向被淘汰的节点
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("胜利节点为"  +helper.getNo());
    }


}


//节点类
class Node{
    //看清楚，我这里两个属性都是私有的，等下被调用时只能通过set、get方法获取或者赋值
    private int  no;
    //看清楚，我这里两个属性都是私有的，等下被调用时只能通过set、get方法获取或者赋值

    private Node next;

    public Node(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}

```



## 第4章 栈



### 4.1 栈的介绍

- 栈的英文（stack）
- 栈是一个后进先出的有序列表
- 栈限制线性表中的元素的插入和删除只能在线性表的同一段进行的特殊线性表，允许插入和删除的一段为变化端，称为栈顶（top），另一端为固定端，称为栈底（Bottom）
- 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素放在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。



**出栈pop，入栈push**

![image-20220823152447905](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220823152447905.png)



**栈的应用场景**

- 子程序调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完毕后再将地址取出来，以回到原先的程序中。
- 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中
- 表达式的转换（中缀表达式转后缀表达式）与求值
- 二叉树的遍历
- 图形的深度优先（depth-first）搜索法

### 4.2 数组模拟栈

![image-20220823153210528](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220823153210528.png)



**代码实现**

```java
package com.ldm.stack;

import java.util.Scanner;

/**
 * @author 梁东明
 * 2022/8/23
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class ArrayStackDemo {
    public static void main(String[] args) {
        ArrayStack stack = new ArrayStack(6);
        String key = "";
        //控制是否退出菜单
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop){
            System.out.println("show: 表示显示栈");
            System.out.println("exit:退出程序");
            System.out.println("push:添加数据到栈中");
            System.out.println("pop： 从栈中取出数据");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case "show":
                    stack.list();
                    break;
                case "exit":
                    scanner.close();
                    loop =false;
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.println("取出的数据是："+ res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序已退出。。。");

    }
}
class ArrayStack{
    private int maxSize;     //栈的大小
    private int[] stack;      //存放栈的数据
    private int top = -1;     //初始化top = -1

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize]; //初始化数组栈的容量
    }

    //判断栈满
    public boolean isFull(){

        return top == maxSize - 1;
    }
    //判断栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //入栈
    public void push(int value){
        //判断栈满
        if (isFull()){
            System.out.println("栈满，无法插入元素");
            return;
        }
        top ++;
        stack[top] = value;
    }
    //出栈
    public int pop(){
        //判断是否空栈
        if (isEmpty()){
            throw new RuntimeException("栈空，无法出栈");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈元素遍历栈，从栈顶开始
    public void list(){
        //判断栈是否为null
        if (isEmpty()){
            System.out.println("没有元素");
            return;
        }
        //从栈顶显示元素
        for (int i = top; i > 0; i--) {
            System.out.println("第" + i +"个元素是："+stack[i]);
        }
    }
}
```



**链表模拟栈（Java）**

```java
package com.ldm.stack;

import java.util.Scanner;

/**
 * @author 梁东明
 * 2022/8/23
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class LinkedListStackDemo {
    public static void main(String[] args) {

        LinkedListStack stack = new LinkedListStack();

        String key = "";
        //控制是否退出菜单
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop){
            System.out.println("show: 表示显示栈");
            System.out.println("exit:退出程序");
            System.out.println("push:添加数据到栈中");
            System.out.println("pop： 从栈中取出数据");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case "show":
                    stack.show();
                    break;
                case "exit":
                    scanner.close();
                    loop =false;
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    Node node = new Node(value);
                    stack.push(node);
                    break;
                case "pop":
                    try {
                        stack.pop();
                        System.out.println("取出的数据是：");
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序已退出。。。");

    }
}

//注意，链栈和数组栈的区别是，数组栈有最大容量限制，而链栈则没有，想插入多少数据就插入多少数据
class LinkedListStack{
    private Node top = new Node(-1);


    //判断栈空
    public boolean isEmpty(){
        return top.getNext() == null;
    }
    //入栈
    public void push(Node node){
        //如果栈中没有元素就插入第一个元素
        if (isEmpty()){
            top.setNext(node);
            return;
        }
        //如果栈中有元素了，就使用头插法的方式入栈
        //定义一个辅助变量指向头节点的下一个节点
        Node temp = top.getNext();

        top.setNext(node);
        node.setNext(temp);

    }

    //出栈
    public void pop(){
        //判断栈是否为null
        if (top == null) {
            System.out.println("栈为null，无法出栈。。。");
            return;
        }
        System.out.println("出栈节点为：" + top.getNext().getData());
        top = top.getNext();
    }
    //遍历链表栈
    public void show(){
        //判断栈是否为null
        if (isEmpty()) {
            System.out.println("栈为null，没有元素。。。");
            return;
        }
        Node temp = top;
        while (true) {
            // 将temp后移， 一定小心空指针异常，我就是没有这个if语句，害我找bug花了两个小时
            if (temp.getNext() != null){
                // 输出节点的信息
                System.out.println(temp.getNext().getData());
                temp = temp.getNext();
            }
        }
    }


}

class Node{
    private int data;
    private  Node next;


    public Node(int data) {
        this.data = data;
    }

    public int getData() {
        return data;
    }

    public void setData(int data) {
        this.data = data;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}

```

### 4.3 栈实现综合计算机

**使用栈完成表达式的计算思路**

**中缀表达式**



- 通过一个index（索引），来遍历我们的表达式
- 如果发现是一个数字，就直接push入数栈
- 如果扫描发现是一个符号，就分如下情况
  - 如果发现当前扫描的符号栈是空的，就直接push入符号栈
  - 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数，再从符号栈pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。
- 当表达式扫描完毕，就按照顺序从数栈和符号栈中pop出相应的数和符号，并运算。
- 最后在数栈只有一个数字，就是表达式的结果。

![image-20220823185217084](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220823185217084.png)



```java
//numStack.push(ch - 48); //? "1+3" '1' => 1
//分析思路
//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
//2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈
//3. 因此我们需要定义一个变量 字符串，用于拼接
```



最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 4.4 前缀、中缀、后缀表达式

#### 4.4.1 前缀表达式

**1、前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前**

- 前缀表达式的计算机求值



![image-20220824161427083](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824161427083.png)

#### 4.4.2 中缀表达式

**中缀表达式就是常见的运算表达式**

![image-20220824162012397](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824162012397.png)

#### 4.4.3 后缀表达式（逆波兰式）

**每两个值，加上后面的一个运算符作为一次运算**



![image-20220824162330063](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824162330063.png)



**后缀表达式的计算机求值**

![image-20220824162406463](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824162406463.png)





#### 4.4.4 逆波兰计算器

**1、输入一个逆波兰表达式（后缀表达式），使用栈，计算其结果**

**2、支持小括号和多位数整数**

**3、思路分析**



**4、代码**![image-20220824162406463](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824162406463.png)

```java
package com.ldm.stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author 梁东明
 * 2022/8/24
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class PolandNotation {
    public static void main(String[] args) {


		//先定义给逆波兰表达式
		//(30+4)×5-6  => 30 4 + 5 × 6 - => 164
		// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
		//测试
		//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开
		//String suffixExpression = "3 4 + 5 * 6 -"  ==29;
		//String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
		//思路
		//1. 先将 "3 4 + 5 × 6 - " => 放到ArrayList中
		//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
        String suffixExpression = "30 4 + 5 * 6 -";
		List<String> list = getListString(suffixExpression);
		System.out.println("rpnList=" + list);

        int res = calculator(list);
        System.out.println("res = " + res);

    }
    public static List<String > getListString(String suffixExpression){
        //将表达式分割
        String[] s = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String  data : s) {
            list.add(data);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
	/*
	 * 1)从左至右扫描，将3和4压入堆栈；
		2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
		3)将5入栈；
		4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
		5)将6入栈；
		6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果
	 */
    public static int calculator(List<String> ls){
        //创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历 ls
        for (String item : ls) {
            //使用正则表达式取出数来
            if ( item.matches("\\d+")){ //匹配的是多位数
                //入栈
                stack.push(item);
            }else {
                //pop出两个数，并运算，在入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1 + num2;
                }else if (item.equals("-")){
                    res = num2 - num1;
                }else if (item.equals("*")){
                    res = num1 * num2;
                }else  if (item.equals("/")){
                    res = num2 / num2 ;
                }else {
                    throw new RuntimeException("没有这种运算符");
                }
            //把res入栈
            stack.push(""+ res  );
            }

        }
        //最后留在栈中的值就是运算得到的值
        return Integer.parseInt(stack.pop());
    }
}


```

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

#### 4.4.5 中缀表达式转后缀表达式（逆波兰计算器）

**具体步骤**

- 1）初始化两个栈： 运算符栈s1和存储中间结果的栈s2
- 2）从左至右扫描中缀表达式
- 3）遇到操作数时，将其压入s2
- 4）遇到运算符时，比较其与s1栈顶运算符的优先级：
  - （1）如果s1为null，或栈顶运算符为左括号”（“，则直接将此运算符入栈
  - （2）否则，若优先级比栈顶运算符的高，也将运算符压入s1
  - （3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到  （4-1）中与s1中新的栈顶运算符想比较

- 5）遇到括号的
  - （1）如果是左括号”（“ ，则直接压入s1
  - （2）如果是右括号”）“，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
- 6）重复步骤2-5，直到表达式的最右边
- 7）将s1中剩余的运算符依次弹出并压入s2
- 8）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
- ![image-20220824221719833](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824221719833.png)

- 

![image-20220824193157432](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220824193157432.png)



```java
package com.ldm.stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author 梁东明
 * 2022/8/24
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */
@SuppressWarnings({"all"})
public class PolandNotation {
    public static void main(String[] args) {

        //完成将一个中缀表达式转成后缀表达式的功能
        //说明
        //1. 1+((2+3)×4)-5 => 转成  1 2 3 + 4 × + 5 –
        //2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List
        //   即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        //3. 将得到的中缀表达式对应的List => 后缀表达式对应的List
        //   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
        String expression = "1+((2+3)*4)-5";//注意表达式
        List<String> list = getMiddleExpressionListString(expression);
        System.out.println("中缀表达式= " + list);

        List<String> parseSuffixExpressionList = parseSuffixExpressionList(list);
        System.out.println("后缀表达式 = " + parseSuffixExpressionList);

        int res = calculator(parseSuffixExpressionList);
        System.out.println("最后的计算结果是 = " + res);

       /*
            先定义给逆波兰表达式
		//(30+4)×5-6  => 30 4 + 5 × 6 - => 164
		// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
		//测试
		//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开
		//String suffixExpression = "3 4 + 5 * 6 -"  ==29;
		//String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
		//思路
		//1. 先将 "3 4 + 5 × 6 - " => 放到ArrayList中
		//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
        String suffixExpression = "30 4 + 5 * 6 -";
		List<String> list = getListString(suffixExpression);
		System.out.println("rpnList=" + list);

        int res = calculator(list);
        System.out.println("res = " + res);*/

    }
    //3. 将得到的中缀表达式对应的List => 后缀表达式对应的List
    //   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
    public static List<String> parseSuffixExpressionList(List<String> ls){
        //定义两个栈 符号栈s1 和存放中间结果的栈s2
        Stack<String> s1 = new Stack<>();

        //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
        //因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
        //Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈s2
        List<String> s2 = new ArrayList<String>(); // 储存中间结果的Lists2

        //遍历传入的ls
        for (String item : ls) {
            //如果是一个数，就加入s2中,要使用正则表达式，开启多位数的识别
            if (item.matches("\\d+")){
                s2.add(item);
            } else if (item.equals("(")) {
                s1.push(item);
            } else if (item.equals(")")) {
                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while(!s1.peek().equals("(")) {
                    s2.add(s1.pop());
                }
                s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号
            }else {
                //当item的优先级小于或者等于   s1 栈顶的运算符
                // 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
                //编写一个Operate类，再编写getValue方法来获取当前运算符的优先级
                while (s1.size() != 0 && Operation.getValue(s1.peek()) >=Operation.getValue(item)){
                    //把s1中的运算符加入s2，直到，item的优先级大于s1栈顶的运算符,退出循环，并且将item压入s1
                    s2.add(s1.pop());
                }
                //还需要将item压入栈
                s1.push(item);
            }

        }
        //将s1中剩余的运算符依次弹出并加入s2
        while(s1.size() != 0) {
            s2.add(s1.pop());
        }

        return s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List


    }


    //将中缀表达式转换成对应的list
    // s 对应的是中缀表达式expression
    public static List<String > getMiddleExpressionListString(String s){
        //定义一个List,存放中缀表达式 对应的内容
        List<String> ls = new ArrayList<>();
        int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串
        String str; // 对多位数的拼接
        char c; // 每遍历到一个字符，就放入到c
        do {

            //为什么是47  58 你要去问编写ASCII码的那群家伙。
            //47对应的是0 58对应的是9，不信的可以去百度查一下
            //如果c是一个非数字，我需要加入到ls
            if((c=s.charAt(i)) < 48 ||  (c=s.charAt(i)) > 57) {
                ls.add("" + c);
                i++; //i需要后移
            } else { //如果是一个数，需要考虑多位数
                str = ""; //先将str 置成"" '0'[48]->'9'[57]
                while(i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {
                    str += c;//拼接
                    i++;
                }
                ls.add(str);
            }
        }while(i < s.length());
        return ls;//返回
    }

    //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中
    public static List<String > getListString(String suffixExpression){
        //将表达式分割
        String[] s = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String  data : s) {
            list.add(data);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
	/*
	 * 1)从左至右扫描，将3和4压入堆栈；
		2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
		3)将5入栈；
		4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
		5)将6入栈；
		6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果
	 */
    public static int calculator(List<String> ls){
        //创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历 ls
        for (String item : ls) {
            //使用正则表达式取出数来
            if ( item.matches("\\d+")){ //匹配的是多位数
                //入栈
                stack.push(item);
            }else {
                //pop出两个数，并运算，在入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1 + num2;
                }else if (item.equals("-")){
                    res = num2 - num1;
                }else if (item.equals("*")){
                    res = num1 * num2;
                }else  if (item.equals("/")){
                    res = num2 / num2 ;
                }else {
                    throw new RuntimeException("没有这种运算符");
                }
            //把res入栈
            stack.push(""+ res  );
            }

        }
        //最后留在栈中的值就是运算得到的值
        return Integer.parseInt(stack.pop());
    }
}


//编写一个类 Operation 可以返回一个运算符 对应的优先级
class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation) {
        int result = 0;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("不存在该运算符" + operation);
                break;
        }
        return result;
    }

}

```



//本次逆波兰计算器出自韩顺平的 [数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=42&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
在  36-42p，视频共有六个，大约在两小时左右。二倍速一个小时即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第5章 递归

### 5.1 递归介绍

**简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，让代码变得更加简洁**



### 5.2 递归调用机制

先来看两段代码，看看有什么区别，它们分别输出什么？

```java

public class RecursionTest {
    public static void main(String[] args) {
        test(4);
    }
    public static  void test(int n){
      if (n > 2){
          test(n -1 );
      }
        System.out.println("n = " + n);
    }
}
```



```java

public class RecursionTest {
    public static void main(String[] args) {
        test(4);
    }
    public static  void test(int n){
      if (n > 2){
          test(n -1 );
      }else {
        System.out.println("n = " + n);
        }
    }
}
```



**相信刚学递归的同学，可能会出错。**

公布答案

第一段代码控制台输出的是

n = 2

n = 3

n =4

第二段代码控制台输出的是

n = 2

如果不了解JVM内存结构的话可能很难搞清楚为什么，但是画一下图可能就会清晰很多了。

- 由于递归不断的调用自己，导致JVM内存中不断的开辟一个独立的空间（栈），

- 所以当 n = 2 时，栈中最上方的空间的判断条件成立了，控制台输出 n = 2

- 最上方的方法执行完之后返回调用它的方法，执行调用者的方法

- 重复上一步，直到栈中的方法全部被执行，当前程序才会真正的退出。

- 这样控制台旧输出

  - n = 2

    n = 3

    n =4

- 至于第二段代码为什么只输出n = 2 ，是因为方法中满足if条件才会输出内容。

- 很明显只有当 n = 2 时，才满足if条件，所以就输出了 n = 2

![image-20220825145939327](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220825145939327.png)



### 5.3 递归解决的问题

1）各种数学问题：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子问题

2）各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等等

3）将用栈解决的问题 --> 递归代码比较简洁



### 5.4 递归需要遵守的重要规则

1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）

2）方法的局部变量是独立的，不会相互影响

补充：如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据

3）方法必须向退出递归的条件逼近，否则就是无限递归，导致栈溢出异常

4）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕了。



### 5.5 迷宫回溯问题

![image-20220825180503309](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220825180503309.png)

-  //findWay方法专门找迷宫的出路
      //1、如果找到就置为true
      //map是二维数组，并表示迷宫
      //i，j表示老鼠的位置
      //0表示可以走，1表示障碍物  2表示可以走 3表示走过但是走不通的死路
      //当map[6][2] == 2,表示走出迷宫
      //确定老鼠走路的策略

![image-20220825163117850](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220825163117850.png)



```java
package com.ldm.recursion;

/**
 * @author 梁东明
 * 2022/8/25
 * 86139
 * 点击setting在Editor 的File and Code Templates 修改
 */

//小老鼠迷宫找出路
//map[1][1] 老鼠额初始地址
//map[6][5] 迷宫的终点 
public class MiGong {
    public static void main(String[] args) {
        int[][] map = new int[8][7];

        //第1行和第8行的全部数据置为1
        for(int i = 0 ; i <7 ; i++){
            map[0][i] = 1;
            map[7][i] = 1;
        }
        //第1列和第7的值置为1
        for (int i = 1; i < 8;i++){
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //第4行的第1-5列置为1
        for (int i = 1; i < 5; i++) {
            map[3][i] = 1;
        }
        //第6行的3-6列置为1
        for (int i = 2; i < 6; i++) {
            map[5][i] = 1;
        }
        map[2][3] = 1;


        System.out.println("===迷宫的情况如下====");
        //遍历输出二维数组
        for (int i = 0 ; i < map.length; i++){
            for (int j = 0; j< map[i].length; j++){
                System.out.print(map[i][j]+"  ");
            }
            System.out.println();
        }

        T t = new T();
        t.findWay(map, 1,1);
        System.out.println("===找路的情况如下====");
        //遍历输出二维数组
        for (int i = 0 ; i < map.length; i++){
            for (int j = 0; j< map[i].length; j++){
                System.out.print(map[i][j]+"  ");
            }
            System.out.println();
        }


    }
}
class T{
    //findWay方法专门找迷宫的出路
    //1、如果找到就置为true
    //map是二维数组，并表示迷宫
    //i，j表示老鼠的位置
    //0表示可以走，1表示障碍物  2表示可以走 3表示走过但是走不通的死路
    //当map[6][2] == 2,表示走出迷宫
    //确定老鼠走路的策略
    public boolean findWay(int[][] map,int i,int j ){

        if (map[6][5] ==2){ //找到出路
            return true;
        }else {
            if (map[i][j] == 0){  //当前位置为0，此路可走
                //假定可以走的通
                map[i][j] = 2;
                //开始判断哪一条路可以走
                if (findWay(map, i+1, j)){ //如果上面的节点为0，置为true。继续向上走
                    return true;
                }else if (findWay(map, i, j+1)){  //如果右边的节点为0，置为true。继续向右走
                    return true;
                }else if (findWay(map, i-1, j)){  //如果下面的节点为0，置为true。继续向下走
                    return true;
                }else if (findWay(map, i, j-1)){  //如果左边的节点为0，置为true。继续向左走
                    return true;
                }else {     //如果走不通的节点置为3，表示走不通
                    map[i][j] = 3;
                    return false;
                }
            }else {
                return false;
            }
        }

    }
}
```



### 5.6 递归-八皇后问题（回溯算法）

**八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际象棋棋手马克斯*贝瑟斯于1848年提出：在8*8格的国际象棋上摆放八个皇后，使其不能处于同一行、同一列或同一斜线，问有多少种摆法**



#### 5.6.1 解题思路

1）第一个皇后放在第一行、第一列
2）第二个皇后放在第二行第一列，然后判断是否可以这样摆放，如果不可以，就继续放在第二行第二列、第三列、依次把所有的列放完，找到一个合适的
3）继续放第三个皇后，还是第一列、第二列。。。。直到第8个皇后也放
在一个不冲突的位置，这时，视为找到一个正确解
4）当得到一个正确解时，在栈回退到上一个栈，就会开始回溯，即将第一个皇后，放在第一列的所有正确解全部得到。
5）然后回头继续放第一个皇后放在第二列，后面继续循环执行1、2、3、4的步骤



![image-20220825204106885](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220825204106885.png)





#### 5.6.2 代码实现

```java
package com.ldm.recursion;

/**
 * @author 梁东明
 * 2022/8/25
 * 86139
 * 8皇后递归
 * 人生小建议，看不懂的方法或者类记得CTRL + 点击 看看注解
 */
public class Queue8 {
    //定义一个max表示有多少个皇后
    int max = 8;
    //定义数组array，保存皇后放置位置的结果，比如 arr = { 0 , 4, 7, 5, 2, 6, 1, 3}
    int[] arr = new int[max];
    static int count = 0;//这个变量是统计有多少种解法
    static int judgeCount; //这个变量是统计回溯了多少次的
    public static void main(String[] args) {
        //测试代码
        Queue8 queue8 = new Queue8();
        //这里的0，是从第一个皇后放起，不影响你有多少个皇后，因为一开始就定义了max = 8；
        queue8.check(0);
        System.out.println("一共有 = " + count+"解法");
        System.out.println("一共有判断冲突的 = " + judgeCount+" 次回溯次数");
    }
    /**
     * 编写一个方法，放置第n个皇后
     * 特别注意：check 是每一次递归时，就会进入check中都有 for（int i = 0; i < max ;i++),因此会有回溯
     * 回溯就是把上一层没走完的for循环走下去，不是把本次的for循环走完，很重要的知识点！！！！，家人们一定要记住
     * @param n 表示第几个皇后
     */
    private void check(int n){
        if (n == max){  //如果n是第八个皇后，说明已经放完全部的皇后
            print();
            return;
        }
        /*
        //依次放入皇后，并判断是否冲突
        //for循环的快捷键就是fori，
        //可以直接写max.fori就可以迅速打印for循环啦！
        //无聊的小知识又增加了
        */
        for (int i = 0; i < max; i++) {
            //先把当前的皇后n，放到该行的第一列
            arr[n] = i;

            //判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)){ //不冲突
                //接着放置n+1个皇后，即开始递归 很重要！！！！！！一定要看懂这行代码
                check(n+1);
            }
            //如果冲突，就继续执行arr[n] = i;但是i在循环中，下一次循环i=i+1;即 将第n个皇后，放置在本行的后移一个位置
        }
    }




    /**
     *  查看当我们放置第n个皇后,就去检测该皇后是否和前面已经摆放的皇后冲突
     * @param n 表示第n个皇后
     * @return
     */
    private boolean judge(int n){
        judgeCount++;
        for (int i = 0; i < n; i++) {
            if (arr[i] ==arr[n] || Math.abs(n-i) == Math.abs(arr[n]-arr[i])){
                /*
                //如果两个皇后在同一列会相互攻击，同一斜线也会相互攻击，同一行也会相互攻击，所以要排除
                ///Math.abs ctrl+点击进去看源码可以知道这是用来求绝对值的
                //更详细的说法是： 行数的差值不能等于列数的差值，相等就说明在同一斜线上
                //数学学过吧？ 把y=x在象限画出来就可以很清楚理解了 斜率为1，在同一条斜线上
                //你可能会说，还有一个是否在同一行没有判断，如果皇后同一行也会相互攻击
                //但是你有没有想过：n是递增的，它们是不可能在同一行的 ，所以不需要判断在同一行
                 */
                return false;
            }
        }
        return true;
    }
    /**
     * 写一个方法，可以将皇后摆放的位置打印出来
     */
    private void print(){
        count++;
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}

```

本次n皇后问题出自韩顺平的 [数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=47&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
在  47-49p，视频共有三个，不到一个小时。二倍速半小时即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第6章 排序

### 6.1 排序算法的介绍

**排序也称排序算法**

（Sort Algorithm），排序是将一组数据，依指定的顺序进行排序

**排序的分类：**

- 1）内部排序：指将需要处理的所有数据都加载到指定内部存储器种进行排序

  - 插入排序：
    - 直接插入排序
    - 希尔排序
  - 选择排序
    - 简单选择排序
    - 堆排序
  - 交换排序
    - 冒泡排序
    - 快速排序
  - 归并排序
  - 基数排序

- 2）外部排序：

  - 数据量太大，无法全部加载到内存中，需要借助外部存储进行排序

  



本次n皇后问题出自韩顺平的 [数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=47&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
在  47-49p，视频共有三个，不到一个小时。二倍速半小时即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 6.2 算法的时间复杂度

**度量一个程序（算法）执行的两种方法**

- 1）事后统计的方法

  这种方法可行，但是有两个问题：一是想对设计的算法的运行性能进行评测，需要实际运行该程序：二是所得时间统计量依赖计算机的硬件、软件等环境因素，这种方式要在同一台计算机相同状态运行下，才能比较哪个算法速度快

- 2）事前估算的方法

  通过分析某个算法的时间复杂度来判断哪个算法更优 。



#### 6.2.1 时间频度

**基本介绍**

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度记为T（n）。

先给出几个结论：

**结论：忽略常数项**

**结论：忽略低次项**

**结论：忽略系数**



![image-20220826155403747](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826155403747.png)

**结论：忽略常数项**

![image-20220826155621052](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826155621052.png)

**结论：忽略低次项**

![image-20220826155813206](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826155813206.png)

**结论：忽略系数**

![image-20220826160050676](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826160050676.png)



#### 6.2.2 时间复杂度

- 1）一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T（n）表示，若有某个辅助函数f（n），使得当n趋近无穷大时，T（n）/ f（n）的极限值不等于零的常熟，则称f（n）是T（n）同数量级别的函数。记作T（n） = O （f（n）），称 O （f（n））为算法的渐进时间复杂度，简称时间复杂度。
- 2）T（n）不同，但是时间复杂度可能相同。
- 计算时间复杂度的方法：
  - 用常数1代替运行时间中所有加法常数
  - 修改后的运行次数函数中，只保留最高阶项
  - 去除最高阶项的系数。

![image-20220826160530237](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826160530237.png)



#### 6.2.3 常见的时间复杂度

1）常数阶O（1）

2）对数阶O（log2n）

3）线性阶O（n）

4）线性对数阶O（nlog2n）

5）平方阶O（n²）

6）立方阶O（n³）

7）k次方阶O（n的k次方）

8）指数阶O（2的n次方）

//**一定要死死记住时间复杂的大小顺序，最好把它刻在DNA上**



![image-20220826161915231](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826161915231.png)



**1）常数阶O（1）**

无论代码执行了多少行，只要没有循环等复杂结构，那么这个代码的时间复杂度就是O（1）

![image-20220826164729574](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826164729574.png)

**2）对数阶O（log2n）**

例子：a的x次方等于N，那么x叫以a为底N的对数，记作x = logaN。其中

a叫对数的底数，N 叫做真数，x叫做“以a为底N的对数”

![image-20220826164841669](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826164841669.png)



![image-20220826170546785](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826170546785.png)



**3）线性阶O（n）**

![image-20220826170804058](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826170804058.png)

**4）线性对数阶O（nlog2n）**

![image-20220826170907041](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826170907041.png)

**5）平方阶O（n²）**

![image-20220826170940115](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826170940115.png)

**6）立方阶O（n³）**



**7）k次方阶O（n的k次方）**



**8）指数阶O（2的n次方）**



#### 6.3 最坏时间复杂度

**平均时间复杂度和最坏时间复杂度**

1）平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间

2）最坏情况下的时间复杂度称为最坏时间复杂度。一般讨论的时间复杂度均是以最坏情况下的时间复杂度，原因：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法 的运行时间不会比最坏情况更长

3）平均时间复杂度和最坏时间复杂度是否一致，和算法有关



![image-20220826180829401](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826180829401.png)



### 6.3 空间复杂度

#### 6.3.1 基本介绍

1）类似时间复杂度的讨论，一个算法的空间复杂度（space Complexity）定义为该算法所消耗的存储空间，它是问题规模n的函数

2）空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，入如快速排序和归并排序算法就是属于这种情况

3）在做算法分析时在，主要讨论的是时间复杂度，从用户使用体验上看，更看重程序执行的速度，一些缓存产品（redis、memcache）和算法（基数排序）的本质就是用空间换时间。



**本次时间复杂度教程出自韩顺平的 [数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=53&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在  51-53p，视频共有三个，不到一个小时。二倍速半小时即可看完。
 最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。**





### 6.4 冒泡排序

**基本介绍**

冒泡排序（Bubble Sort）的基本思想是：通过对排序序列从前向后（从下标较小的元素开始）依次比较相邻元素的值，若发现逆序则交换，使得值比较大的元素逐渐从前向后移动，就像水底下的气泡一样逐渐向上冒



**因为排序过程中，各元素不断接近自己的位置，如果一趟比较下来没有交换过，就说明序列是有序的，因此要在排序过程中设置一个标志flag判断元素是否进行交换过。从而减少 不必要的比较**

![image-20220826204242296](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826204242296.png)



```java
package com.ldm.sort;

/**
 * @author 梁东明
 * 2022/8/26
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BubbleSort {
    public static void main(String[] args) {
        //int[] arr= {3, 8, 1, 17, 9, 13};
        
        //给有100个乱序数据的数组排序
        int[] randomArray = new int[100];
        //插入数据当然要遍历啦！！！
        for (int i = 0; i < randomArray.length; i++) {
            //如果不会使用Math接口的方法，不用担心
            //我会在文章的尾部提供JDK8相关的官方接口文档，直接搜索查看就行啦！！！
            randomArray[i] = (int)(Math.random()*100);  //随机生成0-100的随机数
        }
        
        BubbleSortMethod(randomArray);

    }
    public static void BubbleSortMethod(int[] arr){
        System.out.println("排序之前");
        //遍历输出数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
        int temp = 0;
        for (int i = 0; i < arr.length-1; i++) {
            for (int j = 0; j < arr.length-1 -i; j++) {
                if (arr[j] > arr[j+1]){
                    temp  = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }

        System.out.println("\n"+"排序之后");
        //遍历输出数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

    }
}

```



### 6.5 选择排序

**基本介绍**

选择排序也属于内部排序法，是从欲排序的数据中，按照指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**排序思想**

选择排序（select Sorting） 也是一种简单的排序方法，他的基本思想是：第一次从arr[0] ~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]选取最小值，与arr[1]交换....... 直到第n-1次从arr[n-2]~arr[n-1]选取最小值，与arr[n-2]交换，总共提供n-1次，得到一个按排序码从小到大的有序序列

![image-20220826220218341](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220826220218341.png)



```java
package com.ldm.sort;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/26
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class SelectSort {
    public static void main(String[] args) {
        int arr[] = {55,33,22,75,21,2};
        System.out.println("排序前~");
        System.out.println(Arrays.toString(arr));
        selectSort(arr);
        System.out.println("排序后~");
        System.out.println(Arrays.toString(arr));
    }
   /* public static void selectSort(int[] arr){

        //选择排序的时间复杂度是O(n^2)
        //抱歉！因为本身就会选择排序，所以没有啥注解
        //建议去bi站搜韩顺平数据结构 第58p有详细注解
        for (int i = 0; i < arr.length -1; i++) {

            int minIndex = i;
            int min = arr[i];
            //把i = 0 这个数取出来之后再从数组取一个数出来比较
            //如果存在比min小的数，交换节点，继续遍历第 i+1 个节点直到
            //找到当前比较中最小的节点。让她和arr[i]交换
            for (int j =i + 1; j < arr.length; j++) {
                if (min > arr[j]){
                    min = arr[j];
                    minIndex = j;
                }
            }
                if (minIndex != i) {
                    arr[minIndex] = arr[i];
                    arr[i] = min;
                }
//        System.out.println("第"+(i+1)+"轮后");
//        System.out.println(Arrays.toString(arr));
        }
    }
*/
    public static void selectSort(int[] arr){
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i; //用来定位最小值的下标
            int min = arr[i]; //默认初始最小值，就是当前循环的第一个节点
            //j = i + 1 是因为取出从i开始到 arr.length 的节点与i比较大小，自然要+1啦
            for (int j = i + 1; j < arr.length; j++) {
                if (min >arr[j]){  //如果最小值比循环中任意一个节点大，说明他不是最小值
                    min = arr[j];  //把比最小值还小的值赋给最小值
                    minIndex = j;  //所以最小值的下标记得变成  真最小值 的下标
                    //记住啦，这时候 最小值已经是 arr[j] 啦！ 也就是说arr[minIndex] = arr[j]
                }
                //但这个for循环结束之后，最小值通过不断的比较，已经找到啦，
                //就是arr[minIndex] 至于为什么不是arr[j]是因为j会++变而minIndex不会变
            }
            //如果minIndex不是i说明交换过节点，
            //所以，需要重新让最小值和arr[i]交换节点
            //再把arr[i]置为最小值
            if (minIndex != i) {
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
    }
}


```





本次选择排序出自韩顺平的数据结构与算法

 [数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=47&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
在  57-59p，视频共有三个，不到一个小时。二倍速半小时即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 6.6 插入排序

**插入排序思想**

插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

![image-20220827151433353](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220827151433353.png)





```Java 
package com.ldm.sort;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/27
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 *
 * 插入排序
 */
public class InsertSort {
    public static void main(String[] args) {

        int arr[] = {89,12,44,14,51,28,87,1};

       /* int arr[] = new int[8000];
        //在数组随机插入8000条数据看一下执行时间
        for (int i = 0; i < 8000; i++) {
            arr[i] = (int)(Math.random()*100); //每个数的大小范围在100之内
        }*/



        //千万不要与8000条数据的数组执行这条输出语句,否则你的控制台会输出8000个字符，影响美观
        System.out.println(Arrays.toString(arr));
        //看一下将8000条数据排序需要多少时间吧
        long start = System.currentTimeMillis();
        insertSort(arr); //在这里设置一个断点，然后debug看一下程序的执行路径
        long end = System.currentTimeMillis();
        System.out.println(Arrays.toString(arr));
        System.out.println("排序的时间是：" + (end-start)+ "毫秒");

        //System.out.println(Arrays.toString(arr));
    }

    /**
     * 这个是我按照解题思路自己敲的代码,没有注解,总共才12行.
     * 你可以看下一个方法,有非常详细的注解
     * @param arr
     */
    public static void insertSort2(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int insertValue = arr[i];
            int insertIndex = i - 1 ;
            while(insertIndex >=0 && insertValue < arr[insertIndex]){
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            if (insertIndex + 1 != i){
                arr[insertIndex + 1] = insertValue;
            }
        }
    }

    /**
     * 插入排序
     * @param arr 传入一个一维数组
     * 建议找张纸跟着步骤画一下图,不然真的很难理解的.
     *
     */
    public static void insertSort(int[] arr){
        for (int i = 1; i < arr.length; i++) {  //i是从1开始的喔，要记住哦！
            int insertVal = arr[i];  //要插入的数，i之后的数是无序的哦！
            int insertIndex = i - 1;  //i之前的元素都是有序的哦！，默认是arr[0]是有序的,容量为1.
            /*
            //while循环的意义是：每次循环都把无序表的第一个元素
            //通过与有序表的元素比较，找到合适插入的位置,退出循环
            //insertIndex >= 0 防止数组越界
            //insertVal < arr[insertIndex] 就是按照小到大的顺序排序
             */
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex]; //arr[insertIndex]后移
                //因为要插入的数要插入被比较过的数的前面,对数组数据进行插入时需要将后面的元素后移,这就是arr[insertIndex]后移的原因

                insertIndex--;  //这是让insertVal与有序表中的数进行再次比较,
                //当insertVal > arr[insertIndex] 就会退出while循环
                // insertIndex--; 意味着有序表是逆序遍历的.
                //韩老师的代码我起码看了七八遍才懂,这里你一下子看不懂也是很正常的.所以,如果想真的弄懂的话
                //要花点苦功夫去韩老师的教程去认真的学,学习最主要的就是迎难而上,如果看不懂就放弃了,我觉得这是意见很悲哀的事情
                //因为知识是免费的,你现在学不会,以后可能就要为学不进去而付出代价.
            }

            //当退出while循环,说明插入的位置已经找到,这时候让insertVal放在有序表中insertIndex的后面啦!
            //插入之前要判断是否需要赋值,只有insertIndex + 1 == i需要赋值,那我们就不让它等于i顺便帮它赋值
            if (insertIndex + 1 != i){
                arr[insertIndex + 1] = insertVal;
            }
        }
    }
}

```



本次插入排序出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=61&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 60-62p，视频共有三个，不到一个小时。二倍速半小时即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 6.7 希尔排序

**希尔排序的介绍**

希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。本质也是一种插入排序，它是简单插入排序经过改进之后的版本，称为缩小增量排序



**基本思想**

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序：随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1，整个文件恰好被分成一组，算法终止。

![image-20220827221830528](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220827221830528.png)



```java
package com.ldm.sort;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/27
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 希尔排序
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
        shellSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     *自己写的代码
     * 交换式
     * @param arr
     */
    public static void shellSort(int[] arr){
        int temp = 0;
        int count = 0;
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap ; i < arr.length; i++) {
                for (int j = i -gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]){
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
            System.out.println("第"+(++count)+"轮:\n"+Arrays.toString(arr));
        }
    }

    /**
     * 移位式
     * @param arr
     */
    public static void shellSort2(int[] arr){
        for (int gap = arr.length / 2; gap > 0 ; gap /= 2) {//缩小增量
            for (int i = gap; i <arr.length ; i++) { //插入排序
              int j = i;  //保存待插入节点的索引
              int temp = arr[j];  //保存待插入节点:来自无序表,用来和有序表的节点比较,找到合适位置再插入
               if (arr[j] < arr[j - gap]){//小于同组的前一个节点,需要遍历前一个节点为尾巴的有序表
                   //j - gap >= 0防止数组越界,,开始遍历
                   while(j - gap >= 0 && temp < arr[j -gap]){
                       arr[j] = arr[j - gap];
                       j -= gap;
                   }
                   arr[j] = temp;
               }

            }
        }
    }
    /**
     * 移位式
     *自己写的第二遍,增强记忆
     * 
     */
    public static void shellSort3(int[] arr){
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap;  i < arr.length ; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]){
                    while(j - gap >= 0 && temp < arr[j - gap]){
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
            }
        }
    }
    /**
     * 老师的希尔排序分析
     * @param arr
     */
    public static void shellSort1(int[] arr){
        int temp = 0;
        //逐步推导,比较好理解
        //第一轮把10个数据分为5组
        for (int i = 5; i <arr.length ; i++) {
            //遍历各组中所有的元素(共5组,每组两个数据),步长5
            for (int j = i - 5; j >= 0 ; j -= 5) {
                if (arr[j] > arr[j + 5]){ //谁节点大就交换节点,没啥好解释的.
                    temp = arr[j];
                    arr[j] = arr[j + 5];
                    arr[j + 5] = temp;
                }
            }
        }
        System.out.println("第一轮希尔排序后:\n"+ Arrays.toString(arr));

        //第二轮把10个数据分为5/2 = 2组
        for (int i = 2; i <arr.length ; i++) {
            //遍历各组中所有的元素(共5组,每组两个数据),步长2
            for (int j = i - 2; j >= 0 ; j -= 2) {
                if (arr[j] > arr[j + 2]){ //谁节点大就交换节点,没啥好解释的.
                    temp = arr[j];
                    arr[j] = arr[j + 2];
                    arr[j + 2] = temp;
                }
            }
        }
        System.out.println("第二轮希尔排序后:\n"+ Arrays.toString(arr));
        //第三轮把10个数据分为 2/2 = 1 组
        for (int i = 1; i <arr.length ; i++) {
            //遍历各组中所有的元素(共5组,每组两个数据),步长1
            for (int j = i - 1; j >= 0 ; j -= 1) {
                if (arr[j] > arr[j + 1]){ //谁节点大就交换节点,没啥好解释的.
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        System.out.println("第三轮希尔排序后:\n"+ Arrays.toString(arr));
    }
}


```



本次希尔排序出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=66&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 63 -65p，视频共有三个，不到一个小时。二倍速20分钟即可看完。你确定不去听听韩老师的课？

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 6.8 快速排序

（最好情况好O（nlogn）最坏情况O（n2））

快速排序（Quicksort）是对冒泡排序的一种改进，基本思想：

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后按照此方法对这两部分数据分别进行快速排序（递归），整个排序过程可以递归进行，以此达到整个数据变成有序序列

**快速排序法思路分析**

![image-20220828145902744](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220828145902744.png)



```
package com.ldm.sort;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/28
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 快速排序
 */
public class QuickSort {

    public static void main(String[] args){
        //随机生成20个100以内的数插入数组中
        int arr[] = new int[20];
        for (int i = 0; i < 20; i++) {
            arr[i] = (int)(Math.random()*100);
        }
        System.out.println("排序前~\n"+ Arrays.toString(arr));
        quickSort1(arr, 0, arr.length-1);
        System.out.println("排序后~\n"+ Arrays.toString(arr));
    }
    
    //这里的代码太繁杂了,我上网上找了另外一份更好理解的代码并做了更详细的注解
/*    public static void quickSort(int[] arr,int low,int high){

        int i = low;  //保存数组的第一个索引
        int j = high; //保存数组最后一个索引
        int middle = arr[(low+high) / 2];  //我的基准值是中间值,你可以自己随意设置,你喜欢就好
        int temp;  //辅助节点,用来交换节点的

        //while循环的意义是遍历数组
        //比middle大的数放在右边
        //比middle小的数放在左边
        while (i<j) {
            //先看右边，依次往左递减
            while (middle<=arr[j]&&i<j) {
                j--;
            }
            //再看左边，依次往右递增
            while (middle>=arr[i]&&i<j) {
                i++;
            }
            if(i>=j){  //如果low大于high
                break;
            }
            //如果满足条件则交换

            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;

            if (arr[i] == middle){
                j -= 1;
            }
            if (arr[j] == middle){
                i += 1;
            }

        }
        if (i == j){
            i += 1;
            j -= 1;
        }
        //递归调用左半数组
        if (low < j){
            quickSort(arr, low, j);
        }
        //递归调用右半数组
        if (high > i){
            quickSort(arr, i, high);
        }
    }*/
    public static void quickSort1(int[] arr, int left, int right){
        int i = left;   //保存数组的第一个索引
        int j= right;   //保存数组最后一个索引
        int temp = 0;   //辅助节点,用来交换节点的
        int x;          //基准值

        //判断什么时候退出方法,当然是
        if (left > right){
            return;
        }
        x = arr[left];  //我的基准值是第一个值,你可以自己随意设置,你喜欢就好
        //while循环的意义是让 i 和 j 同时遍历数组
        //比middle大的数放在右边
        //比middle小的数放在左边
        while (i < j){
            //j遍历数组右边  j--,右边的数要大于基准值
            while (x < arr[j] && i < j){
                j--;
            }
            //i遍历数组左边  i++,左边的数要小于基准值
            while (x > arr[i] && i < j){
                i++;
            }
            //当前两个while循环退出,说明出现了右边的值比middle小,左边的值比middle大
            //所以要交换这两个节点,交换之前,需要判断数组是否越界,借助临时变量temp来交换节点
            if (i < j){
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }

        }
        //当第一个while循环遍历完成,说明第一遍遍历完成了,接下来就要开始递归啦!!!
        //递归前,需要将基准值修改,将基准值和i j 相等的地方数字交换
        arr[left] = arr[i];
        arr[i] = x;

        //递归调用左边数组
        quickSort1(arr,left, j-1);
        //递归调用右边数组
        quickSort1(arr,j + 1, right);

    }

}

```



### 6.9 归并排序

s时间复杂度（O（nlogn））

**基本介绍**

归并排序（MERGE—SORT） 是利用归并的思想实现的排序方式，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则是将分的阶段得到的各答案“修补”在一起，即分而治之。

![image-20220828232752012](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220828232752012.png)

- 

![image-20220828233038164](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220828233038164.png)



代码实现

思路分析：

先把数组递归分成很小的一个组

然后再合并

```
package com.ldm.sort;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/29
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {8,4,5,7,1,3,6,2};
        int[] temp = new int[arr.length];  //归并排序需要额外的空间
        //本人非常建议你在此处下一个断点,跟着debug一步一步查看代码的执行过程
        //这样有利于你理解代码,否则单单看注解很难看懂.
        mergerSort(arr,0, arr.length-1, temp);
        System.out.println("归并排序后~\n"+ Arrays.toString(arr));
    }
    //下面两个方法充分利用 分-治 的思想
    /**
     * 分解的方法
     * @param arr  排序的数组
     * @param left  左边有序列表的初始索引
     * @param right  右边的索引
     * @param temp  做中转的临时数组
     */
    public static void mergerSort(int[] arr, int left, int right, int[] temp){
        if (left < right){
            int mid = (left+right)/2; //中间索引
            //向左递归进行分解
            mergerSort(arr, left, mid, temp);
            //向右递归进行分解
            mergerSort(arr,mid+1,right,temp);

            //合并
            merge(arr,left,mid,right,temp);
        }
    }

    /**
     * //合并方法
     * @param arr  排序的数组
     * @param left  左边有序列表的初始索引
     * @param mid    中间索引
     * @param right  右边的索引
     * @param temp  做中转的临时数组
     */
    public static void merge(int[] arr,int left, int mid,int right,int[] temp){
        int i = left;   //初始化i,左边有序序列的初始索引
        int j = mid +1 ;   //初始化j,右边有序序列的初始索引
        int t = 0;       //指向temp数组的当前索引

        //第一步:
        //先把左右两边有序的数据按照规则填充到temp数组
        //直到左右两边的有序序列,有一边完全处理完毕
        while (i <=mid && j<=right){ //开始遍历左右两边
            if(arr[i] < arr[j]){ //谁小谁就进入temp数组,记得后移,方便后续遍历
                temp[t] = arr[i];
                t++;
                i++;
            }else{
                temp[t] = arr[j];
                t++;
                j++;
            }
        }
        //第二步:
        //把有数据剩余的一边也插入temp数组中
        while (i <= mid){  //可能是左边有序序列有剩余
            temp[t] = arr[i];
            i++;
            t++;
        }
        while (j <= right){  //也有可能是右边有序序列有剩余
            temp[t] = arr[j];
            j++;
            t++;
        }
        //第三步:.
        //把temp数组的元素重新插入到arr中
        //注意,并不是每次拷贝所有数据
        t = 0;
        int tempLeft = left;
        System.out.println("tempLeft=\t"+tempLeft +"\tright=\t"+ right);
        while(tempLeft <= right ){
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }
    }
}

```



本次归并排序出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 69-71p，视频共有三个，不到一个小时。二倍速20分钟即可看完。你确定不去听听韩老师的课？

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 6.10 基数排序

**基本介绍**

1）基数排序（radix sort）属于“分配式排序” （distribution sort），又称“桶子法”（bucket sort）或bin sort 顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用

2）基数排序式属于稳定性的排序，基数排序法的是效率高的稳定性排序法

3）基数排序是桶排序的扩展

4）基数排序 是1887年赫尔曼—赫勒里发明的，它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。



**基本思想**

1）将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后，从最低位开始，依次进行一次排序。这样从最低为排序一直到最高位排序完成以后，数列就变成一个有序序列

2）看图文解释，理解基数排序的步骤。

![image-20220829192017203](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220829192017203.png)

- 

![image-20220829192113621](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220829192113621.png)

**很明显，基数排序就是空间换时间，花费大量空间来换取执行时间**

```java
package com.ldm.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {

    public static void main(String[] args) {
        int arr[] = { 53, 3, 542, 748, 14, 214};

        // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G
//		int[] arr = new int[8000000];
//		for (int i = 0; i < 8000000; i++) {
//			arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
//		}
        System.out.println("排序前");
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);

        radixSort(arr);

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序前的时间是=" + date2Str);

        System.out.println("基数排序后 " + Arrays.toString(arr));

    }

    //基数排序方法
    public static void radixSort(int[] arr) {

        //根据前面的推导过程，我们可以得到最终的基数排序代码

        //1. 得到数组中最大的数的位数
        int max = arr[0]; //假设第一数就是最大数
        for(int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength = (max + "").length();


        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组
        //说明
        //1. 二维数组包含10个一维数组
        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length
        //3. 名明确，基数排序是使用空间换时间的经典算法
        int[][] bucket = new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数
        //可以这里理解
        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数
        int[] bucketElementCounts = new int[10];


        //这里我们使用循环将代码处理

        for(int i = 0 , n = 1; i < maxLength; i++, n *= 10) {
            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..
            for(int j = 0; j < arr.length; j++) {
                //取出每个元素的对应位的值
                int digitOfElement = arr[j] / n % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
            int index = 0;
            //遍历每一桶，并将桶中是数据，放入到原数组
            for(int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中，有数据，我们才放入到原数组
                if(bucketElementCounts[k] != 0) {
                    //循环该桶即第k个桶(即第k个一维数组), 放入
                    for(int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出元素放入到arr
                        arr[index++] = bucket[k][l];
                    }
                }
                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
                bucketElementCounts[k] = 0;

            }
            //System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr));

        }

		/*

		//第1轮(针对每个元素的个位进行排序处理)
		for(int j = 0; j < arr.length; j++) {
			//取出每个元素的个位的值
			int digitOfElement = arr[j] / 1 % 10;
			//放入到对应的桶中
			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
			bucketElementCounts[digitOfElement]++;
		}
		//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
		int index = 0;
		//遍历每一桶，并将桶中是数据，放入到原数组
		for(int k = 0; k < bucketElementCounts.length; k++) {
			//如果桶中，有数据，我们才放入到原数组
			if(bucketElementCounts[k] != 0) {
				//循环该桶即第k个桶(即第k个一维数组), 放入
				for(int l = 0; l < bucketElementCounts[k]; l++) {
					//取出元素放入到arr
					arr[index++] = bucket[k][l];
				}
			}
			//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
			bucketElementCounts[k] = 0;

		}
		System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr));


		//==========================================

		//第2轮(针对每个元素的十位进行排序处理)
		for (int j = 0; j < arr.length; j++) {
			// 取出每个元素的十位的值
			int digitOfElement = arr[j] / 10  % 10; //748 / 10 => 74 % 10 => 4
			// 放入到对应的桶中
			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
			bucketElementCounts[digitOfElement]++;
		}
		// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
		index = 0;
		// 遍历每一桶，并将桶中是数据，放入到原数组
		for (int k = 0; k < bucketElementCounts.length; k++) {
			// 如果桶中，有数据，我们才放入到原数组
			if (bucketElementCounts[k] != 0) {
				// 循环该桶即第k个桶(即第k个一维数组), 放入
				for (int l = 0; l < bucketElementCounts[k]; l++) {
					// 取出元素放入到arr
					arr[index++] = bucket[k][l];
				}
			}
			//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
			bucketElementCounts[k] = 0;
		}
		System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr));


		//第3轮(针对每个元素的百位进行排序处理)
		for (int j = 0; j < arr.length; j++) {
			// 取出每个元素的百位的值
			int digitOfElement = arr[j] / 100 % 10; // 748 / 100 => 7 % 10 = 7
			// 放入到对应的桶中
			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
			bucketElementCounts[digitOfElement]++;
		}
		// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
		index = 0;
		// 遍历每一桶，并将桶中是数据，放入到原数组
		for (int k = 0; k < bucketElementCounts.length; k++) {
			// 如果桶中，有数据，我们才放入到原数组
			if (bucketElementCounts[k] != 0) {
				// 循环该桶即第k个桶(即第k个一维数组), 放入
				for (int l = 0; l < bucketElementCounts[k]; l++) {
					// 取出元素放入到arr
					arr[index++] = bucket[k][l];
				}
			}
			//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
			bucketElementCounts[k] = 0;
		}
		System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */

    }
}

```



### 6.11 排序算法的时间复杂度比较



![image-20220829192343863](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220829192343863.png)







## 第7章 查找

### 7.1 查找算法介绍

1）顺序（线性）查找

2）二分查找/折半查找

3）插值查找

4）斐波那契查找



### 7.2 线性查找

- 按照数组的顺序一直查找下去，花费的时间比较多，不适合大数据的查找

```
package com.ldm.search;

/**
 * @author 梁东明
 * 2022/8/29
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 线性查找
 */
public class SeqSearch {
    public static void main(String[] args) {

        int[] arr = {1,33,23,56,12,46,23,86,35,25};
        int index = seqSearch(arr,25);
        if (index ==-1){
            System.out.println("数组中没有这个值...");
        }else {
            System.out.println("该值的下标是:"+index);
        }
    }

    /**
     *线性查找,找到满足条件的值就返回下标
     * @param arr 数组
     * @param value  要查找的值
     * @return 返回的值的下标,没有就返回-1
     */
    public static int seqSearch(int[] arr,int value){
        //线性查找是逐一比对,发现有相同值,就返回下标
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}

```



### 7.3 二分（折半）查找

注意事项：二分查找适合的对象是**有序序列**

- 思路分析

1、首先确定该数组的中间下标mid  = （left+right） / 2

2、然后让需要查找的数findVal和arr[mid]比较

- findVal>arr[mid]，说明需要查找的数在mid的右边，递归向右查找
- findVal<arr[mid]，说明需要查找的数在mid的左边，递归向左查找

- findVal == arr[mid]，说明找到，返回该值或下标

//什么时候结束递归

1）找到就结束递归

2）递归完整个数组，仍然没有找到findVal，也需要结束递归。当left > right，就需要退出

**代码实现**

```java
package com.ldm.search;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 梁东明
 * 2022/8/30
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 二分查找（折半）查找（适用于有序序列）
 */
public class BinarySearch {
    public static void main(String[] args) {
        int arr[] = {1,3,3,3,5,7,9,13,34,45,78};
        /*//切记arr是有序数组！！！！二分查找只适合有序数组
        //我一开始跟着老师代码完全一样就是报 栈溢出 的错误
        //通过debug才发现我的arr一开始是无序的。又一次加深印象了.原来二分查找只适合有序序列。
        int binarySearch = binarySearch(arr, 0, arr.length - 1, 79);
        System.out.println("binarySearch = " + binarySearch);*/

        List<Integer> integers = binarySearch2(arr, 0, arr.length - 1, 3);
        System.out.println("值为3的下标分别为 = " + integers);
    }


    /**
     * //二分查找算法
     * @param arr 被查找的数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal  要查找的值
     * @return   返回要查找的值或者-1
     */
    public static int binarySearch(int[] arr, int left, int right,int findVal){
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if (left > right){
            return -1;
        }

        if ( findVal > midVal ){
            //开始向右递归
            return binarySearch(arr, mid+1,right,findVal);
        }else if (findVal < midVal){
            //开始向左递归
            return binarySearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }
    /**
     * //对二分查找算法优化
     * 即查找的值有多个相同的值，将所有相同的值查找出来
     *
     * 思路分析：
     * 1、找到mid值时不用立即返回。
     * 2、向mid索引值的左边扫描将满足的的相同值的下标保存在集合ArrayList
     * 3、向mid索引值的右边扫描将满足的的相同值的下标保存在集合ArrayList
     * 4、返回ArrayList
     * @param arr 被查找的数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal  要查找的值
     * @return   返回要查找的值或者-1
     */
    public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
        System.out.println("查找次数");
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        //这时候不能返回-1啦，要返回一个空的Integer集合
        if (left > right){
            return new ArrayList<Integer>();
        }

        if ( findVal > midVal ){
            //开始向右递归
            return binarySearch2(arr, mid+1,right,findVal);
        }else if (findVal < midVal){
            //开始向左递归
            return binarySearch2(arr,left,mid-1,findVal);
        }else {
            List<Integer> resIndexList = new ArrayList<>();
           // 2、向mid索引值的左边扫描将满足的的相同值的下标保存在集合ArrayList
            int temp = mid -1;
            while (true) {
                if (temp < 0 || arr[temp] != findVal){
                    break;
                }
                //将相同的值保存在集合中
                resIndexList.add(temp);
                temp --;  //temp左移
            }
            resIndexList.add(mid);
            // 3、向mid索引值的右边扫描将满足的的相同值的下标保存在集合ArrayList
            temp = mid +1;
            while (true) {
                if (temp > arr.length -1 || arr[temp] != findVal){
                    break;
                }
                //将相同的值保存在集合中
                resIndexList.add(temp);
                temp ++;  //temp右移
            }
            return resIndexList;
        }
    }
}

```



### 7.4 插值查找算法

**插值查找算法原理介绍**

1）插值查找算法类似于 **二分查找**，不同的是插值查找每次从自适应mid处开始查找

2）将折半查找中求mid索引的公式，low表示左边索引，high表示右边索引。

![image-20220830141425303](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220830141425303.png)

**分享一条助理解的例子给大家看看**

你可以把上面两条公式的 （ 1/2）    与    （key - a[low] / a[high] -a[low] ） 分别取出比较

首先，数组必须是有序序列，

例如： {1，2，3，4，5}中找到2，

用（插入查找公式）（key - a[low] / a[high] -a[low] )<==>( 2-1）/（5-1）=1/4 

用（二分查找公式）1/2 相比之下1/4比1/2小 ,缩小搜索范围。

**这个式子的意义：所查找的数字的位置占数组总长度的比例**

3）int midIndex = low +（high - low ）*（key -arr[low])    /  (arr[high] - arr[low]); /*插值索引*/



**代码实现**



```java
package com.ldm.search;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author 梁东明
 * 2022/8/30
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 插值查找
 * 插值查找与二分查找的区别：查找次数比二分查找少；查找的mid值不同
 */
public class InsertValueSearch {
    public static void main(String[] args) {
        //先创建一个容量为100，1为第一个值的递增数组
        int arr[] = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i+1;
        }
        int i = insertValueSearch(arr, 0, arr.length - 1, 64);
        System.out.println("64的索引是 = " + i);



    }

    /**
     * 编写插值查找算法，要求：数组是有序的
     * @param arr 数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal 查找的值
     * @return  返回值,找到直接返回，没找到就返回-1
     */
    public static int insertValueSearch(int[] arr,int left,int right, int findVal){
        System.out.println("查找次数");
        //在数组中没找到该值，返回-1 比二分查找多了一个条件：判断mid是否越界
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]){
            return -1;
        }
        //求出mid
        int mid = left + (right - left)*(findVal -arr[left])/(arr[right] -arr[left]);
        int midVal = arr[mid];
        if ( findVal > midVal ){
            //开始向右递归
            return insertValueSearch(arr, mid+1,right,findVal);
        }else if (findVal < midVal){
            //开始向左递归
            return insertValueSearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }

}

```



**插值查找的注意事项：**

1）对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快

2）对于关键字分布不均匀的情况下，该方法不一定比二分查找要好。



本次二分、插入查找教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 78-82p，视频共有五个，不到一个小半时。二倍速30多分钟即可看完。你确定不去听听韩老师的课？

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 7.5 斐波那契查找法

**基本介绍**

斐波那契查找原理与前面两种相似，仅仅改变中间节点（mid）的位置，mid不再是中间或者插值得到，而是位于黄金分割点附近，即mid = low+F（k - 1）-1，F代表斐波那契数列。

![image-20220831120843246](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220831120843246.png)

**代码实现**



```java
package com.ldm.search;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/8/30
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 斐波那契查找法
 */
public class FibonacciSearch {
    public static int maxSize=20;
    public static void main(String[] args) {
        int arr[] = {1,8,10,89,1000,1234};
        fibonacciSearch(arr,10);
    }
    //先定义一个斐波那契数列
    //斐波那契数列的长度一定要大于或者等于arr的长度
    //非递归得到一个斐波那契数列
    public static int[] fibo(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }


    /**编写斐波那契查找算法
     * 最重要的是理解mid值的由来一定要懂，
     * 你已经是个成年人了要学会debug来测试代码了
     *非递归的方式
     * @param arr 数组
     * @param key 需要查找的关键字
     * @return 返回对应的下标，没有就返回-1
     */
    public static int fibonacciSearch(int[] arr, int key){
        int low = 0;
        int high = arr.length - 1;
        int k = 0; //表示斐波那契分割数值的下标
        int mid = 0; //存放mid值
        int f[] = fibo(); //获取到斐波那契数列
        //获取到斐波那契分割数值的下标
        while (high > f[k] - 1){
            k++;
        }
        //因为f[k]的值可能大于a的长度。因此需要使用Arrays类，构造一个新的数组，并指向arr[]
        //不足的部分会用0来填充
        int[] temp = Arrays.copyOf(arr,f[k]);
        //实际上需要使用a数组最后的数填充temp
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = arr[high];
        }
        //使用while循环，来找到key值
        while (low <= high){
            mid = low + f[k - 1] - 1;
            if (key < temp[mid]){  //遍历数组的左边
                high = mid -1;
                k--;
            }else if (key > temp[mid]){
                low = mid + 1;
                k -=2;
            }else {
                if ( mid <= high){
                    return mid;
                }else {
                    return high;
                }
            }
        }
        return -1;
    }
}

```





本次二分、插入查找教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 78-82p，视频共有五个，不到一个小半时。二倍速30多分钟即可看完。你确定不去听听韩老师的课？

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第8章 哈希表

hashtable

### 8.1 Google上机题

有一个公司，当有新的员工来报道时，要求将该员工的信息加入（id、性别、年龄、名字、住址...）当输入该员工的id时，要求查找到该员工的所有信息

**要求：不使用数据库，尽量节省内存，速度越快越好=>哈希表（散列）**



```java
package com.ldm.hashtab;

import java.util.Scanner;

/**
 * @author 梁东明
 * 2022/8/31
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HashTableDemo {
    public static void main(String[] args) {
        //创建hashtable
        HashTab hashTab = new HashTab(7);

        //创建菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("add:添加员工");
            System.out.println("list:显示员工");
            System.out.println("find:查找员工");
            System.out.println("exit:退出程序");

            key = scanner.next();
            switch (key) {
                case "add" :
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    //创建员工
                    Emp emp = new Emp(id, name);
                    hashTab.add(emp);
                    break;
                case "list" :
                    hashTab.list();
                    break;
                case "find" :
                    System.out.println("请输入要查找的id");
                    id = scanner.nextInt();
                    hashTab.findEmpById(id);
                    break;
                case "exit" :
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }

    }
}
//创建Hashtable 管理多条链表
class HashTab{
    private EmpLinkedList[] empLinkedListArray ;
    private int size;  //表示有多少条链表

    //构造器
    public HashTab(int size) {
        this.size = size;
        //初始化empLinkedListArrays
        empLinkedListArray = new EmpLinkedList[size];
        //分别初始化每个链表
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }
    /**
     * 添加雇员的方法
     */
    public void add(Emp emp){
        //根据员工id得到该员工应当添加到那一条链表
        int empLikedListNo = hashFun(emp.id);
        //将emp添加到对应的链表中
        empLinkedListArray[empLikedListNo].add(emp);

    }
    /**ad
     * 遍历哈希表
     */
    public void list(){
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }
    /**
     * 根据输入的i，查找员工
     *
     */
    public void findEmpById(int id){
        //使用散列函数确定到哪一条链表
        int empLinkedListNo = hashFun(id);
         Emp emp = empLinkedListArray[empLinkedListNo].findById(id);
         if (emp != null){ //找到
             System.out.println("在第"+(empLinkedListNo+1)+"条链表找到该员工的信息：: "+" id="+id+"\tname="+emp.name);
         }else { //没有找到
             System.out.println("在哈希表中没有找到该员工");
         }
    }
    /**
     * 编写散列函数
     * 使用一个简单的取模法
     */
    public int hashFun(int id){
        return id % size;
    }
}

//表示雇员
class Emp{
    public int id;
    public String  name;
    public Emp next; //默认为null

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
//创建EmpLikedList，表示链表
class EmpLinkedList{
    //头指针，执行第一个Emp，，因此链表的head是指向第一个Emp
    private Emp head;



    /**
     * 添加员工到链表
     *1、假定当添加员工时，id是自增长的
     *2、因此，把雇员直接加入到本链表的最后即可
     * @param emp  传入的员工
     */
    public void add(Emp emp){
        //遍历链表，创建临时变量辅助遍历
        //如果是第一个节点，就把传入的一个员工添加
        if (head == null){
            head = emp;
            return;
        }
        Emp temp = head;
        while (true){
            //到达链表的尾部，退出循环。找到链表的尾部
            if (temp.next ==null){
                break;
            }
            temp = temp.next;
        }
        //退出循环之后，把传入的节点插入到temp.next
        temp.next = emp;
    }
    /**
     * 遍历链表
     */
    public void list(int no){
        //判断链表是否为null
        if (head == null){
            System.out.println("第"+(no+1)+"条链表是null，退出。。。");
            return;
        }
        Emp temp = head;
        while (true){
            System.out.println("第"+(no+1) +"条链表信息:\n" +"=>"+"id="+temp.id+ "\t"+"name="+temp.name);
            if (temp.next ==null){
                break;
            }
            temp = temp.next;
        }
        System.out.println();
    }
    /**
     * 根据id查找员工
     * @param id 传入员工id
     * @return 找到就返回，找不到就返回null
     */
    public Emp findById(int id){
        //判断链表是否为null
        if (head ==null){
            System.out.println("当前链表为null，请返回");
            return null;
        }
        //辅助指针
        Emp temp = head;
        while (true) {
            if (temp.id == id){ //找到就直接返回
                break;
            }//退出循环
            if (temp.next == null){ //说明链表中没有找到该员工
                temp = null;
                break;
            }
            temp = temp.next;
        }
        return temp;
    }
}

```



本次哈希表教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 83-89p，视频共有六个，不到一个小半时。二倍速30多分钟即可看完。你确定不去听听韩老师的课？

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 8.2 哈希表介绍

散列表（Hash table）也叫哈希表，根据关键码值（key -value）而直接进行访问的数据结构，也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度，这个映射函数就叫做散列函数，存放记录的数组就叫散列表。

![image-20220831123352112](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220831123352112.png)





## 第9章 二叉树

### 9.1 为什么需要树

**分析树与其他存储结构的优缺点**

1）数组存储方式的分析

优点：通过下标方式访问元素，速度快，对于有序数组，还可以使用二分查找提高检索速度。

缺点：如果要检索具体某个值，或者插入值（按一定顺序)会整体移动，效率低

2）链式存储方式的分析

优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要插入节点，链接到链表中即可，删除效率也很好）

缺点：在进行检索时，效率依然低下（比如检索某个值，需要从头节点开始遍历）

3）树存储方式的分析

能提高数据存储，读取的效率，比如利用二叉排序树（BinarySort Tree）既可以保证数据的 检索速度，同时也可以保证数据的插入，删除，修改的速度。

例子：

![image-20220831193039842](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220831193039842.png)



### 9.2 树的常用术语

**树的常用术语**

1）节点

2）根节点

3）父节点

4）子节点

5）叶子节点（没有子节点的节点）

6）节点的权（节点的值）

7）路径（从root节点找到该节点的路线）

8）层

9）子树

10）树的高度（最大 层数）

11）森林：多颗子树构成森林

![image-20220831193440496](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220831193440496.png)



### 9.3 二叉树

#### 9.3.1 二叉树的概念

1）树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树

2）二叉树的子节点分为左节点和右节点

3）如果该二叉树的所有叶子节点都在最后一层，并且节点总数==在2^n-1，n为层数，则我们称为满二叉树。

4）如果该二叉树的所有叶子节点都在最后一层或者在倒数第二层，而最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

![image-20220831194314378](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220831194314378.png)



#### 9.3.2 二叉树的前中后许遍历

**前序遍历：先输出父节点，再遍历左子树和右子树**

**中序遍历：先遍历左子树，再输出父节点，再遍历右子树**

**后序遍历：先遍历左子树，再遍历右子树，最后输出父节点**

![image-20220901144840377](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220901144840377.png)

**看输出父节点的顺序，就确定是前中后序遍历啦**

```java
package com.ldm.tree;

/**
 * @author 梁东明
 * 2022/8/31
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建需要的节点
        Node root = new Node(1, "小明");
        Node node2 = new Node(2, "李华");
        Node node3 = new Node(3, "张三");
        Node node4 = new Node(4, "李四");
        Node node5 = new Node(5, "王五");
        //手动创建二叉树，后续学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
        //前序遍历
        System.out.println("前序遍历");
        binaryTree.preorder();
        //中序遍历
        System.out.println("中序遍历");
        binaryTree.infixOrder();
        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder();


    }
}

//定义binaryTree 二叉树
class BinaryTree{
    private Node root;  //定义根节点

    public void setRoot(Node root) {
        this.root = root;
    }
    //前序遍历
    public void preorder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }

}
//先创建节点
class Node{
    private int no;
    private String name;
    private Node left;  //默认为null
    private Node right;  //默认为null


    /**
     * 构造器
     * @param no   编号
     * @param name 名字
     */
    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.preOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.preOrder();
        }

    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.postOrder();
        }

        //递归向左子树的遍历
        if (this.right !=null){
            this.right.postOrder();
        }
        System.out.println(this); //先输出父节点
    }


}

```



#### 9.3.3 二叉树的前中后遍历查找

**思路分析**

**前序查找思路**

1、先判断当前节点的no是否等于要查找的

2、如果是相等，则返回当前节点

3、如果不等，则判断当前节点的左子节点是否为null，如果不为null，则递归前序查找

4、如果左递归前序查找，找到节点，则返回，否则继续判断。当前的节点的右子节点是否为 null，如果不为null。则继续向右递归前序查找

**中序查找思路**

1、判断当前节点的左子节点是否为null，如果不为null，则递归中序查找

2、如果找到，则返回，如果没有找到，就和当前接单比较。如果是则返回当前节点，否则继续进行右递归的中序查找

3、如果右递归中序查找，找到就返回，否则返回null

**后序查找思路**

1、判断当前节点的左子节点是否为null，如果不为null，则递归后序查找。

2、如果找到，就返回，如果没有找到。就判断当前节点的右子节点是否为null，如果不是null，则右递归进行后序查找，如果找到就返回

3、就和当前节点比较，如果是，就返回当前节点，否则就返回null。



![image-20220901162307516](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220901162307516.png)



```java
package com.ldm.tree;

/**
 * @author 梁东明
 * 2022/8/31
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建需要的节点
        Node root = new Node(1, "小明");
        Node node2 = new Node(2, "李华");
        Node node3 = new Node(3, "张三");
        Node node4 = new Node(4, "李四");
        Node node5 = new Node(5, "王五");
        //手动创建二叉树，后续学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
        //前序遍历
        System.out.println("前序遍历");
        binaryTree.preorder();
        //中序遍历
        System.out.println("中序遍历");
        binaryTree.infixOrder();
        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder();

       /* //前序查找
        System.out.println("前序查找");
        Node resNode = binaryTree.preOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }*/
       /* //中序查找
        System.out.println("中序查找");
        Node resNode = binaryTree.infixOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }*/
        //后序查找
        System.out.println("后序查找");
        Node resNode = binaryTree.postOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }
    }
}

//定义binaryTree 二叉树
class BinaryTree{
    private Node root;  //定义根节点

    public void setRoot(Node root) {
        this.root = root;
    }
    //前序遍历
    public void preorder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //前序查找
    public Node preOrderSearch(int no){
        if (this.root != null){
            return root.preOrderSearch(no);
        }else {
           return null;
        }
    }
    //中序查找
    public Node infixOrderSearch(int no){
        if (this.root != null){
            return root.infixOrderSearch(no);
        }else {
            return null;
        }
    }
    //后序查找
    public Node postOrderSearch(int no){
        if (this.root != null){
            return root.postOrderSearch(no);
        }else {
            return null;
        }
    }

}
//先创建节点
class Node{
    private int no;
    private String name;
    private Node left;  //默认为null
    private Node right;  //默认为null


    /**
     * 构造器
     * @param no   编号
     * @param name 名字
     */
    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.preOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.preOrder();
        }

    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.postOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.postOrder();
        }
        System.out.println(this); //先输出父节点
    }

    /**
     * 前序遍历查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node preOrderSearch(int no){

        System.out.println("遍历查找次数");
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //1、判断当前节点是否为null，如果不为null，就前序递归遍历
        //2、如果左递归前序查找，找到节点，直接返回
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        //1、左递归前序查找，找到节点，则返回，否则继续判断
        //2、当前节点的右子节点是否为null，如果不为null，则继续向右递归前序查找
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;

    }

    /**
     * 中缀顺序搜索
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node infixOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归中序查找
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.infixOrderSearch(no);

        }
        //2、如果左递归前序查找，找到节点，直接返回
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点
        if (this.no == no){
            return this;
        }

        //否则继续进行右递归的中序查找
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;

    }
    /**
     * 后序查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node postOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归后序遍历
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.postOrderSearch(no);

        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }

        //如果左子树没有找到，则向右子树进行后序遍历查找
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果左右子树都没有找到，就比较当前节点
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //树中没有该节点就返回null
        return null;

    }


}

```





#### 9.3.4 二叉树的删除节点

**要求**

1、如果删除的节点是叶子节点，则直接删除该节点

2、如果删除的节点是非叶子节点，则删除该子树

![image-20220901163637863](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220901163637863.png)



**完成删除节点的操作**

**思路：**

首先处理：

考虑如果树本身是空树root，如果只有一个root节点，则等价于将二叉树置空

1、因为二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除，而不能去判断当前这个节点是不是需要删除的节点。

2、如果当前节点的左子节点不为null，并且左子节点就是要删除的节点，就将当前节点的left置为null即：this.left=null;并且就返回（结束递归）

3、如果当前节点的右子节点不为null，并且右子节点就是要删除的节点，就将当前节点的right置为null即：this.right=null;并且就返回（结束递归）

4、如果第2、3步没有删除节点，那么需要向左子树进行递归删除

5、如果第4步也没有删除节点，则应当向右子树进行递归删除。

```java
package com.ldm.tree;

/**
 * @author 梁东明
 * 2022/8/31
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建需要的节点
        Node root = new Node(1, "小明");
        Node node2 = new Node(2, "李华");
        Node node3 = new Node(3, "张三");
        Node node4 = new Node(4, "李四");
        Node node5 = new Node(5, "王五");
        //手动创建二叉树，后续学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
  /*      //前序遍历
        System.out.println("前序遍历");
        binaryTree.preorder();
        //中序遍历
        System.out.println("中序遍历");
        binaryTree.infixOrder();
        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder();
*/
       /* //前序查找
        System.out.println("前序查找");
        Node resNode = binaryTree.preOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }*/
       /* //中序查找
        System.out.println("中序查找");
        Node resNode = binaryTree.infixOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }*/
       /* //后序查找
        System.out.println("后序查找");
        Node resNode = binaryTree.postOrderSearch(5);
        if (resNode != null){
            System.out.println("找到了，信息为："+"  编号为："+resNode.getNo()+"\t姓名为："+resNode.getName());
        }else {
            System.out.println("没有找到节点为"+5+"的信息");
        }*/

        //删除qian
        System.out.println("删除前,前序遍历");
        binaryTree.preorder();
        //删除后
        binaryTree.delete(5);
        System.out.println("删除后,前序遍历");
        binaryTree.preorder();
    }
}

//定义binaryTree 二叉树
class BinaryTree{
    private Node root;  //定义根节点

    public void setRoot(Node root) {
        this.root = root;
    }
    //删除节点
    public void delete(int no){
        if (this.root != null){
            //需要判断该树是否只有根节点，是的话只需要删除根节点即可(将root置null）
            if (root.getNo() == no){
                root = null;
            }else {
                this.root.delete(no);
            }
        }else {
            System.out.println("空树，无法删除");
        }
    }
    //前序遍历
    public void preorder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //前序查找
    public Node preOrderSearch(int no){
        if (this.root != null){
            return root.preOrderSearch(no);
        }else {
           return null;
        }
    }
    //中序查找
    public Node infixOrderSearch(int no){
        if (this.root != null){
            return root.infixOrderSearch(no);
        }else {
            return null;
        }
    }
    //后序查找
    public Node postOrderSearch(int no){
        if (this.root != null){
            return root.postOrderSearch(no);
        }else {
            return null;
        }
    }

}
//先创建节点
class Node{
    private int no;
    private String name;
    private Node left;  //默认为null
    private Node right;  //默认为null


    /**
     * 构造器
     * @param no   编号
     * @param name 名字
     */
    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //递归删除节点
    //1、如果删除的是叶子节点，则删除该节点
    //2、如果删除的是非叶子节点，则删除该子树
    public void delete(int no){
        if (this.left != null && this.left.no == no){
            //如果删除的节点就是该节点的左子节点，让他的左子节点置null
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no){
            //如果删除的节点就是该节点的右子节点，让他的右子节点置null
            this.right = null;
            return;
        }
        //如果删除的节点不是当前节点，需要向当前节点的左子树进行递归遍历，找到它并删除删除
        if (this.left != null){
            this.left.delete(no);
        }

        //不要怀疑为什么是当前节点，因为刚开始递归的时候当前节点就是根节点
        //如果删除的节点不是当前节点并且不是其左子节树的节点，需要向其右子树进行递归遍历，找到它并删除删除
        if (this.right != null){
            this.right.delete(no);
        }
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.preOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.preOrder();
        }

    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.postOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.postOrder();
        }
        System.out.println(this); //先输出父节点
    }

    /**
     * 前序遍历查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node preOrderSearch(int no){

        System.out.println("遍历查找次数");
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //1、判断当前节点是否为null，如果不为null，就前序递归遍历
        //2、如果左递归前序查找，找到节点，直接返回
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        //1、左递归前序查找，找到节点，则返回，否则继续判断
        //2、当前节点的右子节点是否为null，如果不为null，则继续向右递归前序查找
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;

    }

    /**
     * 中缀顺序搜索
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node infixOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归中序查找
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.infixOrderSearch(no);

        }
        //2、如果左递归前序查找，找到节点，直接返回
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点
        if (this.no == no){
            return this;
        }

        //否则继续进行右递归的中序查找
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;

    }
    /**
     * 后序查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node postOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归后序遍历
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.postOrderSearch(no);

        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }

        //如果左子树没有找到，则向右子树进行后序遍历查找
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果左右子树都没有找到，就比较当前节点
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //树中没有该节点就返回null
        return null;

    }


}

```



本次二叉树教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 91-99p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 9.4 顺序存储二叉树

**基本说明**

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。



**顺序二叉树的特点**

1）顺序二叉树通常只考虑完全二叉树

2）第n个元素的左子节点为2*n + 1

3）第n个元素的右子节点为2*n + 2

4)第n个元素的父节点为（n - 1） / 2

5）n：表示二叉树中的第几个元素（按0开始编号）

![image-20220901230926501](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220901230926501.png)



```java
package com.ldm.tree;

/**
 * @author 梁东明
 * 2022/9/1
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 顺序二叉树
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int arr[] = { 1, 2, 3, 4, 5, 6, 7 };

        //创建一个ArrBinaryTree的对象
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        arrBinaryTree.preOrder();
    }
}
//编写一个ArrBinaryTree，实现顺序二叉树遍历
class ArrBinaryTree{
    private int[] arr; //存储数据节点的数组

    //构造器
    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }
    //把前序遍历重载，这样在主方法中就不需要传入参数
    public void preOrder(){
        this.preOrder(0);
    }

    /**
     * 完成顺序二叉树的前序遍历
     *
     * @param index 数组下标
     *
     */
    public void preOrder(int index){
        //如果数组为null，或者arr,length = 0
        if (arr ==null ||arr.length == 0){
            System.out.println("数组为null，不能按照二叉树的前序遍历");
        }
        //输出当前节点
        System.out.print("\t"+arr[index]);
        //向左递归遍历
        if ( (index * 2 +1) < arr.length){
            preOrder(index * 2 + 1);
        }
        //向右递归遍历
        //向左递归遍历
        if ( (index * 2 + 2) < arr.length){
            preOrder(index * 2 + 2);
        }
    }
}

```

**八大排序算法中堆排序，就会使用到顺序存储二叉树**



本次顺序存储二叉树教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 100-101p. 20分钟即可看完。

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 9.5 线索化二叉树

**基本介绍**

1）n个节点的二叉链表中含有n+1公式2n-2(n-1)=n+1个空指针。利用二叉链表中的空指针域，存放指向节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针称为“线索”）

2）这个加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（TreadedBinaryTree）根据线索性质不同，线索二叉树可分为前序线索二叉树、中序线索二叉树、后序线索二叉树sanz

3）一个节点的前一个节点：前驱节点

4）一个节点的后一个节点：后继节点



![image-20220902140941192](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220902140941192.png)

 

**遍历线索化二叉树**

说明：对前面的中序线索化的二叉树，进行遍历

分析：因为线索化后，各个节点指向有变化，因此原来的遍历方式不能使用，这时候就需要使用新的方式遍历线索化二叉树，各个节点可以通过线性方式遍历。因此无需使用递归方式，提高了遍历的效率，遍历的次序应当和中序遍历保持一致。



```java
package com.ldm.tree.ThreadedBinaryTree;

/**
 * @author 梁东明
 * 2022/8/31
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
@SuppressWarnings({"all"})
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        Node root = new Node(1, "钱一");
        Node node1 = new Node(3, "赵二");
        Node node2 = new Node(6, "张三");
        Node node3 = new Node(8, "李四");
        Node node4 = new Node(10, "王五");
        Node node5 = new Node(14, "陈六");

        root.setLeft(node1);
        root.setRight(node2);
        node1.setLeft(node3);
        node1.setRight(node4);
        node2.setLeft(node5);

        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadedNodes();

        //测试
        Node left = node4.getLeft();
        System.out.println("10号节点的前驱节点是"+left);
        Node right = node4.getRight();
        System.out.println("10号节点的后继节点是" + right);

        //非递归遍历线索二叉树
        System.out.println("非递归遍历线索二叉树");
        threadedBinaryTree.threadedList();

    }
}

//定义ThreadedbinaryTree 二叉树
class ThreadedBinaryTree{
    private Node root;  //定义根节点

    //为了线索化，需要创建要给指向当前节点的前驱节点的指针
    private Node pre = null;

    public void setRoot(Node root) {
        this.root = root;
    }

    public void threadedNodes(){
        this.threadedNodes(root);
    }
    public void threadedList(){
        Node node = root;  //先获取到根节点，准备开始遍历
        while (node != null){  //根节点不为null，开始遍历，这时

            //这层遍历是找出node.leftType == 1 的节点
            //因为当leftType==1，说明该节点就是按照线索化的
            //前驱节点
            while (node.getLefType() == 0){
                node = node.getLeft();
            }
            //打印这个节点
            System.out.println(node);
            //这层遍历是找出node.rightType == 1 的节点
            //如果当前节点的右指针指向的是后继节点，就一直输出
            while (node.getRightType() == 1){
                node = node.getRight();
                System.out.println(node);
            }
            //替换这个遍历的节点
            node = node.getRight();
        }
    }

    /**
     * 螺纹节点
     * 螺纹节点编写对二叉树进行中序线索化的方法
     *
     * @param node 需要线索化的节点
     */
   /* public void threadedNodes(Node node){
        //如果node为null，不能进行线索化
        if (node == null){
            return;
        }
        //第一步，线索化左子树
        threadedNodes(node.getLeft());
        //第二步：线索化当前节点

        //处理当前节点的前驱节点
        if (node.getLeft() ==null){
            //让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            //修改当前节点的左指针的类型,当前左指针指向的不再是左子树，而是前驱节点
            node.setLefType(1);
        }
        //处理后继节点
        if (pre != null &&pre.getRight() ==null){

            pre.setRight(node);
            pre.setRightType(1);
        }
        //很重要的一行代码，每处理一个节点，让当前节点是下一个节点的前驱
        pre = node;
        //第三步：线索化右子树
        threadedNodes(node.getRight());
    }*/

    //这个是我为了加强记忆手写的，全程无注解，你可以看前面有注解的
    public void threadedNodes(Node node){
        if ( node ==null){
            return;
        }
        threadedNodes(node.getLeft());

        if ( node.getLeft() ==null){
            node.setLeft(pre);
            node.setLefType(1);
        }
        if (pre != null && pre.getRight()==null){
            pre.setRight(node);
            pre .setRightType(1);
        }
        pre  =node;

        threadedNodes(node.getRight());
    }


    //删除节点
    public void delete(int no){
        if (this.root != null){
            //需要判断该树是否只有根节点，是的话只需要删除根节点即可(将root置null）
            if (root.getNo() == no){
                root = null;
            }else {
                this.root.delete(no);
            }
        }else {
            System.out.println("空树，无法删除");
        }
    }
    //前序遍历
    public void preorder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为null，无法遍历");
        }
    }
    //前序查找
    public Node preOrderSearch(int no){
        if (this.root != null){
            return root.preOrderSearch(no);
        }else {
           return null;
        }
    }
    //中序查找
    public Node infixOrderSearch(int no){
        if (this.root != null){
            return root.infixOrderSearch(no);
        }else {
            return null;
        }
    }
    //后序查找
    public Node postOrderSearch(int no){
        if (this.root != null){
            return root.postOrderSearch(no);
        }else {
            return null;
        }
    }

}
//先创建节点
class Node{
    private int no;
    private String name;
    private Node left;  //默认为null
    private Node right;  //默认为null

    //1、如果leftType==0表示指向的是左子树，leftType==1表示指向前驱节点
    //2、如果rightType==0表示指向的是右子树，rightType==1表示指向后继节点
    private int lefType;
    private int rightType;
    /**
     * 构造器
     * @param no   编号
     * @param name 名字
     */
    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getLefType() {
        return lefType;
    }

    public void setLefType(int lefType) {
        this.lefType = lefType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //递归删除节点
    //1、如果删除的是叶子节点，则删除该节点
    //2、如果删除的是非叶子节点，则删除该子树
    public void delete(int no){
        if (this.left != null && this.left.no == no){
            //如果删除的节点就是该节点的左子节点，让他的左子节点置null
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no){
            //如果删除的节点就是该节点的右子节点，让他的右子节点置null
            this.right = null;
            return;
        }
        //如果删除的节点不是当前节点，需要向当前节点的左子树进行递归遍历，找到它并删除删除
        if (this.left != null){
            this.left.delete(no);
        }

        //不要怀疑为什么是当前节点，因为刚开始递归的时候当前节点就是根节点
        //如果删除的节点不是当前节点并且不是其左子节树的节点，需要向其右子树进行递归遍历，找到它并删除删除
        if (this.right != null){
            this.right.delete(no);
        }
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.preOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.preOrder();
        }

    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this); //先输出父节点
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树的遍历
        if (this.left !=null){
            this.left.postOrder();
        }
        //递归向左子树的遍历
        if (this.right !=null){
            this.right.postOrder();
        }
        System.out.println(this); //先输出父节点
    }

    /**
     * 前序遍历查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node preOrderSearch(int no){

        System.out.println("遍历查找次数");
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //1、判断当前节点是否为null，如果不为null，就前序递归遍历
        //2、如果左递归前序查找，找到节点，直接返回
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        //1、左递归前序查找，找到节点，则返回，否则继续判断
        //2、当前节点的右子节点是否为null，如果不为null，则继续向右递归前序查找
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;

    }

    /**
     * 中缀顺序搜索
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node infixOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归中序查找
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.infixOrderSearch(no);

        }
        //2、如果左递归前序查找，找到节点，直接返回
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点
        if (this.no == no){
            return this;
        }

        //否则继续进行右递归的中序查找
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;

    }
    /**
     * 后序查找
     *
     * @param no 编号
     * @return 如果找到就返回Node，如果没有找到就返回null
     */
    public Node postOrderSearch(int no){

        //1、判断当前节点的左子节点是否为null，如果不为null，就递归后序遍历
        Node resNode = null;
        if ( this.left != null){
            resNode = this.left.postOrderSearch(no);

        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }

        //如果左子树没有找到，则向右子树进行后序遍历查找
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){  //说明左递归找打节点了
            return resNode;
        }
        System.out.println("遍历查找次数");
        //如果左右子树都没有找到，就比较当前节点
        //比较当前节点的no等于传入的no
        if (this.no == no){
            return this;
        }
        //树中没有该节点就返回null
        return null;

    }


}

```



本次线索化二叉树教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=71&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 102-106p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 9.6  堆排序

#### 10.1 堆排序基本介绍

1）堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn),它也是一种不稳定的排序。

2）堆石具有以下性质的完全二叉树：

- 每个节点的都大于或等于其左右孩子节点的值，称为大顶堆
- 没有要求节点的左孩子的值和右孩子的值的大小关系
- 每个节点的值都小于或等于其左右孩纸节点的值，称为小顶堆



大顶堆举例说明：

![image-20220902191851418](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220902191851418.png)



小顶堆举例：

![image-20220902192055571](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220902192055571.png)

#### 10.2 堆排序的基本思路

1）将待排序序列构造成一个大顶堆

2）此时，整个序列的最大值就是堆顶的根节点

3）将其与末尾元素进行交换，此时末尾就是最大值

4）然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列

（最后一个非叶子节点==最后一个叶子节点的父节点）

(arr.length-1) / 2



**解题步骤：**

![image-20220902225530822](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220902225530822.png)

- 
- ![image-20220902230100347](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220902230100347.png)

- 
- 

**代码实现**

```Java
package com.ldm.tree;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/2
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 堆排序
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9,-2,99};
        heapSort(arr);
    }
    public static void heapSort(int[] arr){
        System.out.println("堆排序");

        int temp = arr[0]; //把堆顶元素用临时变量保存（arr[0]还不是最大值）
        //1、将无序数组构建出一个堆，根据升降排序的需求选择大顶堆或者小顶堆
        //这样做的目的是将数组最大或最小的值升到堆顶
        //(arr.length-1)/2  从最后一个非叶子节点开始调整堆
        //至于(arr.length-1)/2怎么得来的，我再提一下：
        //最后一个非叶子节点==最后一个叶子节点的父节点
        //最后一个叶子节点的索引就是arr.length
        for (int i = (arr.length-1)/2; i >= 0;i--){
            adjustHeap(arr,i, arr.length);
        }
        //2、上一步已经把数组最大值升到堆顶了
        //所以我们需要将堆顶元素和末尾元素交换，将最大（小）值放到数组末尾
        //重新调整堆，使arr.length-1的元素继续排成大（小）堆顶，最大值不参与下一次的堆所以要arr.length-1
        //然后循环1、2步的操作，直到完全排序好
        //这个for循环是倒序循环的，看清楚了，每次取出的j就是数组末尾的索引
        for (int j = arr.length - 1; j > 0; j--){
            //交换节点，如果这个还不会，赶紧去学冒泡排序
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            //开始调整堆,记住啦j是递减的，所以需要调整的堆会越来越小
            //直到数组被排序完毕
            adjustHeap(arr,0, j);
        }
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 调整堆
     * 功能：完成将以i对应的非叶子节点的树调整成大顶堆
     *（小提示：要学会这个排序，最好先学会完全二叉树，巧了，我主页刚好有教程，
     * 翻一翻，动个小手去学吧！否则代码你只会有用而看不懂。）
     * @param arr    待调整的数组
     * @param i      表示非叶子节点在数组的索引
     * @param length 表示对多少个元素继续调整，length是在逐渐的减少
     */
    public static void adjustHeap(int[] arr, int i, int length){
        int temp = arr[i]; //先取出当前元素的值，保存在临时变量中
        //开始调整堆
        for (int k = 2*i+1; k <length ; k=2*k+1) {  //如果你了解完全二叉树，你就知道i节点的左子节点就是2*i+1，右子节点就是2*i+2，它们的索引相差1
            if (k+1 <length && arr[k] < arr[k+1]){ //防止数组越界  &&  取出当前i节点的左右子节点比较（如果左子节点小于右子节点，指针就指向右子节点）
                k++;  //k++，这样k就指向了右子节点  。把左右子节点最大值取出来，在下一条语句和i比较
            }
            if (arr[k] > temp){  //如果子节点大于父节点
                arr[i] = arr[k];  //就把较大的值赋值给当前i节点
                i = k;   //i指向k，继续循环比较  ，而且还是自下而上（最重要，理解这行代码基本就懂了）对堆调整
            }else {
                break;
            }
        }
        //当for循环结束时，以i为父节点的树的最大值，放在顶部（局部）
        arr[i] = temp; //将temp值放在调整之后的位置
    }
}

```



本次堆排序教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=110&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 107-111p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 9.7 哈夫曼树

**基本介绍**

1）给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树称为最优二叉树，也称为哈夫曼树（Huffmantree）

2）哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近。

**哈夫曼树的几个重要概念**

1）路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或者孙子节点之间的通路，称为路径，通路中分支的数目称为路径长度，若规定根节点的层数为1，则从根节点到L层节点的路径长度为L  -  1

2）节点的权及带权路径长度：若将树中中节点赋给一个有着某种含义的数值，则这个数值成为该节点的权，节点的 带权路径长度为：从根节点到该节点之间的路径长度与该节点的 权的乘积

3）树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL（weighted path length），权值越大的节点离根节点越近的二叉树才是最优二叉树

4）WPL最小的就是哈夫曼树  



**思路分析：**

1）从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看出是一颗最简单的二叉树。

2）取出根节点权值最小的两颗二叉树

3）组成一颗新的二叉树，该二叉树的根节点的权值是前面两颗二叉树根节点权值的和

4）再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1234的步骤，直到数列中，所有的数据都被处理，就得到一颗哈夫曼树。



```java
package com.ldm.HuffmanTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author 梁东明
 * 2022/9/3
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HuffmanTree {
    
    public static void main(String[] args) {
        int[] arr = {13,7,8,3,29,6,1};
        Node root = createHuffmanTree(arr);
        preOrder(root);
    }
    
    
    //前序对根节点进行遍历
    public static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("这是一个空数组。。。");
        }
    }

    /**
     * 创建哈夫曼树
     *
     * @param arr 传入的数组
     * @return 返回根节点
     */
    public static Node createHuffmanTree(int[] arr){

        //先创建list集合，命名为nodes
        List<Node> nodes = new ArrayList<>();
       
        /*看不懂可以用这个普通for循环将arr数组的元素插入list集合中
        for (int i = 0; i < arr.length; i++) {
            nodes.add(new Node(i));
        }*/
        //通过增强for循环将arr数组的元素以节点的形式插入list集合中
        for (int  value : arr) {
            nodes.add(new Node(value));
        }
        //循环list集合，直到list集合只剩一个节点退出循环
        while (nodes.size() > 1){
            //对list集合排序
            Collections.sort(nodes);

            //输出节点
            System.out.println(nodes);

            //取出list集合中的最小两颗权值的二叉树取出来
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            //把他们组合成新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            //把处理过的两个二叉树（节点）从list集合删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //把新的二叉树（节点）插入到list集合中
            nodes.add(parent);
        }
        //退出循环之后，list集合就只剩下一个节点，将它返回
        return nodes.get(0);

    }
}
//创建节点类，实现comparable接口，重写compareTo方法
class Node implements Comparable<Node>{
    public int value;  //权值
    public Node left;  //左节点
    public Node right;  //右节点

    //构造器alt+invest（ins）快捷键快速创建，必须是idea
    public Node(int value) {
        this.value = value;
    }
    //前序遍历的方法
    public void preOrder(){
        System.out.println(this);
        if (this.left != null){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
/*
实现步骤：
看不懂没关系，这是我自己做的代码步骤，然后自己思考，最后手敲出来运行成功会有一种莫名的自豪感
你自己也可以总结实现步骤，自己动手写一遍。
1、在主方法创建数组
2、创建节点类、实现comparable接口
3、创建哈夫曼树方法
4、调用list集合，把数组的值插入list中
5、对list集合里面的节点进行排序，用 Collection的sort方法排序;
6、取出集合中权值最小的两颗二叉树
7、构建新的二叉树
8、从集合中删除前面取出来的两颗二叉树
9、将新的二叉树插入回list集合
10、循环执行步骤6、7、8、9直到list集合只剩一个棵树
11、返回哈夫曼树的root节点
12、前序遍历测试
13、代码执行成功，prefect!!!
 */
```



本次哈夫曼树创建教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=110&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 112-114p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 9.8 哈夫曼编码

**基本介绍**

1）哈夫曼编码（HuffmanCoding），是一种编码方式，属于一种程序算法

2）哈夫曼编码是哈夫曼树在电讯通信中的经典的应用之一

3）哈夫曼编码广泛用于数据文件压缩，其压缩率通常在20~90%之间

4）哈夫曼码是可变字长编码（VLC）的一种。Huffman于1952年提出一种编码方式，称之为最佳编码



**实现步骤：**

1）创建node节点类，包含data、weight、left、right

2）得到“ str”对应的byte[]数组

3）编写一个方法、将准备构建哈夫曼树的node节点放到list，统计字符串中每个字符出现的次数

4）通过list创建对应的哈夫曼树



```java
package com.ldm.HuffmanCode;

import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * @author 梁东明
 * 2022/9/4
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HuffmanCode {
    public static void main(String[] args) {
        String str = "hello my name is ldm";
        byte[] bytes = str.getBytes();   ///用byte[] 保存字符串
        System.out.println("bytes = " + bytes.length);  //输出字符串的长度

        List<Node> nodes = getNodes(bytes);  //不妨ctrl+单击 getNodes方法试试
        System.out.println("nodes = " + nodes);

        //测试创建的哈夫曼树
        System.out.println("前序遍历");
        Node huffmanCodeRoot = createHuffmanCode(nodes);
        preOrder(huffmanCodeRoot);

        //测试是否生成对应的哈夫曼编码
        getCodes(huffmanCodeRoot,"",strBuilder);
        System.out.println("huffmanCodeRoot = " + huffmanCodes);

    }

    /**
     * 前序遍历哈夫曼树
     *
     * @param root 根节点
     */
    private static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("该二叉树为null");
        }
    }
    //将哈夫曼编码保存在map集合中
    static Map<Byte,String> huffmanCodes = new HashMap<Byte,String>();
    //拼接路径，用来存储某个叶子节点的路径
    static StringBuilder strBuilder = new StringBuilder();

    /**
     * 功能：将传入的node节点的所有叶子节点的哈夫曼编码得到，并放入到huffmanCodes集合中
     *
     * @param node       传入的节点
     * @param code       路径： 0是左子节点  1是右子节点
     * @param strBuilder 用于拼接路径
     */
    private static void getCodes(Node node, String code, StringBuilder strBuilder){
        StringBuilder strBuilder2 = new StringBuilder(strBuilder);
        //将code拼接到strBuilder2中
        strBuilder2.append(code);
        if (node != null){ //node ==null 空树不处理
            if (node.data == null){ //新创建的父节点没有data值，即： 非叶子节点
                //向左递归
                getCodes(node.left,"0",strBuilder2);
                //向右递归
                getCodes(node.right,"1",strBuilder2);
            }else {  //上面不是叶子节点，那么这里就是叶子节点
                //表示找到叶子节点,将其保存在map集合中
                huffmanCodes.put(node.data,strBuilder2.toString());
            }

        }
    }


    /**
     * 该方法的用处就是用list集合保存node节点
     * 而且每个节点中保存了 字符串中  每个字符的ASCII码值和出现次数（还排好序了）
     * 等下创建哈夫曼编码用到这个list集合的节点
     *
     * @param bytes 传入的字符串数组
     * @return 返回含有data  、weight 的节点
     */
    private static List<Node> getNodes(byte[] bytes){
        //创建一个list集合，用来保存node节点，命名为nodes
        List<Node> nodes = new ArrayList<>();
        //创建一个map集合，用来统计每个字符出现的次数，命名为map
        //k（bytes的ASCII码值）-v（字符出现的次数）
        Map<Byte, Integer> map = new HashMap<>();
        //遍历字符串数组
        for (byte data : bytes) {

           /*
           Integer count = map.get(data);
           if ( count == null){//k（bytes的ASCII码值）-v（字符出现的次数）如果字符出现的次数为null，就将其插入map集合，
                map.put(data,1);
            }else {
                map.put(data, count+1);//如果字符出现过了，就将其出现次数+1
            }*/

            map.merge(data, 1, Integer::sum);
            //不得不感叹一下JAVA的技术迭代的真快，上面6行的代码，这里一行就能说明清楚。
            //看不懂这个merge方法的，尝试 ctrl+单击 看看JDK源码，顺便看一下全英的注解

        }
        //使用Entry遍历map集合，将每个map集合中的元素插入list集合中
        for (Map.Entry<Byte,Integer> entry: map.entrySet()) {
            //list集合里面的是node节点，所以还需要用到map的k-v来构建node节点
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        //返回list集合
        return nodes;
    }

    /**
     * 创建霍夫曼编码
     * 取出list集合最小的两个节点创建一个二叉树，
     * 把取出来的节点删除，把创建的二叉树插入list集合，循环
     * 直到list集合只剩下一个节点，退出循环，该节点就是哈夫曼树的根节点
     *
     * @param nodes 节点
     * @return {@link Node}
     */
    private static Node createHuffmanCode(List<Node> nodes){
        while ( nodes.size() > 1){
            Collections.sort(nodes);

            //取出list集合最小的两个元素
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            //构建一个二叉树，不存放字符串，只存放权值。
            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            //把用过的节点移出集合
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //把新二叉树放回集合中
            nodes.add(parent);
        }
        return nodes.get(0);
    }
}
//创建带权值的节点类
class Node implements Comparable<Node>{
    Byte data;
    int weight;
    Node left;
    Node right;

    //构造器


    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }
    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left != null ){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
}
/*
我的实现步骤：
1、创建node节点类，包含data、weight、left、right、包含前序遍历的方法
2、主方法中添加str字符串，得到str对应的byte[] 数组
3、编写一个方法将准备好的byte[] 数组中每个字符统计出现次数和按大小排序
  1）通过hashmap将byte[]数组遍历，统计每个字符出现次数并排好序
  2）把每个键值对k-v以一个Node对象加入到List集合中
4、通过3得到的list集合创建哈夫曼树
  1）取出列表最小的两个值
  2）以这两个节点创建父节点（父节点的data值为null，只有权值weight）
  3）在list集合删除那两个节点，把父节点插入list集合、循环
  4）直到list只剩下一个节点，退出循环。哈夫曼树创建完成
5、主方法中调用前序遍历方法，测试是否正确
6、生成对应的哈夫曼编码表
  1)先创建一个map集合用来保存编码
  2）再创建一个stringBuilder用来拼接编码
  3）创建一个方法，将传入的node节点的所有叶子节点的哈夫曼编码得到，
  并放入到huffmanCodes集合中
  4）测试生成的编码是否成功
 */
```



#### 9.8.1 数据压缩

**哈弗编码字节数组**

//编写一个方法，将字符串对应的byte[] 数组，通过生成的哈夫曼编码表，返回一个哈夫曼编码，压缩后的byte[]



步骤：

1、利用HuffmanCodes 将 bytes 转成 哈夫曼编码对应的字符串

遍历bytes数组

```java
 /**
     * 邮政编码
     *
     * @param bytes    原始的字符串对应的byte[] 数组，长度是20
     * @param huffmanCodes 生成的霍夫曼编码
     * @return {@link byte[]} 返回生成的哈夫曼编码处理后的byte[]数组
     * 01010001011011001111110011111110000010110000111011000111111010100110
     *///编写一个方法，将字符串对应的byte[] 数组，通过生成的哈夫曼编码表，返回一个哈夫曼编码，压缩后的byte[]
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {

        //1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历bytes 数组
        for(byte b: bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }

        //System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());

        //将 "1010100010111111110..." 转成 byte[]

        //统计返回  byte[] huffmanCodeBytes 长度
        //一句话 int len = (stringBuilder.length() + 7) / 8;
        int len;
        if(stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8;
        } else {
            len = stringBuilder.length() / 8 + 1;
        }
        //创建 存储压缩后的 byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;//记录是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) { //因为是每8位对应一个byte,所以步长 +8
            String strByte;
            if(i+8 > stringBuilder.length()) {//不够8位
                strByte = stringBuilder.substring(i);
            }else{
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte 转成一个byte,放入到 huffmanCodeBytes
            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
            index++;
        }
        return huffmanCodeBytes;
    }
```



#### 9.8.2 数据解压

![image-20220905191216497](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220905191216497.png)





**代码实现：**

```java
//完成数据的解压
    //1、重写先转成 哈夫曼编码对应的二进制字符串
    //2、哈夫曼编码对应的二进制的字符串、  ==》 对照哈夫曼编码

    //编写一个方法，完成对压缩数据的解码

    //编写一个方法，完成对压缩数据的解码
    /**
     *
     * @param huffmanCodes 赫夫曼编码表 map
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 就是原来的字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes, byte[] huffmanBytes) {

        //1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转成二进制的字符串
        for(int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            //判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length - 1);
            stringBuilder.append(byteToBitString(!flag, b));
        }
        //把字符串安装指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换，因为反向查询 a->100 100->a
        Map<String, Byte>  map = new HashMap<String,Byte>();
        for(Map.Entry<Byte, String> entry: huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }

        //创建要给集合，存放byte
        List<Byte> list = new ArrayList<>();
        //i 可以理解成就是索引,扫描 stringBuilder
        for(int  i = 0; i < stringBuilder.length(); ) {
            int count = 1; // 小的计数器
            boolean flag = true;
            Byte b = null;

            while(flag) {
                //1010100010111...
                //递增的取出 key 1
                String key = stringBuilder.substring(i, i+count);//i 不动，让count移动，指定匹配到一个字符
                b = map.get(key);
                if(b == null) {//说明没有匹配到
                    count++;
                }else {
                    //匹配到
                    flag = false;
                }
            }
            list.add(b);
            i += count;//i 直接移动到 count
        }
        //当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"
        //把list 中的数据放入到byte[] 并返回
        byte b[] = new byte[list.size()];
        for(int i = 0;i < b.length; i++) {
            b[i] = list.get(i);
        }
        return b;

    }


    /**
     * 将一个byte 转成一个二进制的字符串
     * @param b 传入的 byte
     * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位
     * @return 是该b 对应的二进制的字符串，（注意是按补码返回）
     */
    private static String byteToBitString(boolean flag, byte b) {
        //使用变量保存 b
        int temp = b; //将 b 转成 int
        //如果是正数我们还存在补高位
        if(flag) {
            temp |= 256; //按位与 256  1 0000 0000  | 0000 0001 => 1 0000 0001
        }
        String str = Integer.toBinaryString(temp); //返回的是temp对应的二进制的补码
        if(flag) {
            return str.substring(str.length() - 8);
        } else {
            return str;
        }
    }


```



#### 9.8.3 文件压缩



```java
/**
     * zip文件
     *
     * @param srcFile  目标文件
     * @param dstFile 输出文件
     */
    public static void zipFile(String srcFile, String dstFile) {

        //创建输出流
        OutputStream os = null;
        ObjectOutputStream oos = null;
        //创建文件的输入流
        FileInputStream is = null;
        try {
            //创建文件的输入流  
            is = new FileInputStream(srcFile);
            //创建一个和源文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            //读取文件
            is.read(b);
            //直接对源文件压缩
            byte[] huffmanBytes = huffmanZip(b);
            //创建文件的输出流, 存放压缩文件
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的ObjectOutputStream
            oos = new ObjectOutputStream(os);
            //把 赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes); //我们是把
            //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
            //注意一定要把赫夫曼编码 写入压缩文件
            oos.writeObject(huffmanCodes);


        }catch (Exception e) {

            System.out.println(e.getMessage());
        }finally {
            try {
                is.close();
                oos.close();
                os.close();
            }catch (Exception e) {

                System.out.println(e.getMessage());
            }
        }

    }
```



#### 9.8.4 文件解压

```java
//编写一个方法，完成对压缩文件的解压
	/**
	 * 
	 * @param zipFile 准备解压的文件
	 * @param dstFile 将文件解压到哪个路径
	 */
	public static void unZipFile(String zipFile, String dstFile) {
		
		//定义文件输入流
		InputStream is = null;
		//定义一个对象输入流
		ObjectInputStream ois = null;
		//定义文件的输出流
		OutputStream os = null;
		try {
			//创建文件输入流
			is = new FileInputStream(zipFile);
			//创建一个和  is关联的对象输入流
			ois = new ObjectInputStream(is);
			//读取byte数组  huffmanBytes
			byte[] huffmanBytes = (byte[])ois.readObject();
			//读取赫夫曼编码表
			Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();
			
			//解码
			byte[] bytes = decode(huffmanCodes, huffmanBytes);
			//将bytes 数组写入到目标文件
			os = new FileOutputStream(dstFile);
			//写数据到 dstFile 文件
			os.write(bytes);
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		} finally {
			
			try {
				os.close();
				ois.close();
				is.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
			
		}
	}
	
```



#### 9.8.5 哈夫曼编码压缩文件注意事项

1)如果文件本身就是经过压缩处理，那么使用哈夫曼编码再压缩效率不会有明显的变化，比如视频、ppt等等文件

2）哈夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件，文本文件

3）如果一个文件中的内容、重复的数据不多，压缩效果也不会很明显。

#### 9.8.6全部代码



```java
package com.ldm.HuffmanCode;

import javax.tools.FileObject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static java.lang.Integer.parseInt;

/**
 * @author 梁东明
 * 2022/9/4
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HuffmanCode {
    public static void main(String[] args) {
       /* //测试压缩文件
        String srcFile = "D:\\IOTest\\bg.jpg";
        String dstFile = "D:\\IOTest\\a\\bgm.zip";

        zipFile(srcFile,dstFile);
        System.out.println("压缩成功~~");
*/
        /*//测试解压文件
        String zipFile = "D:\\IOTest\\a\\bgm.zip";
        String distFile = "D:\\IOTest\\bgm.jpg";

        unZipFile(zipFile,distFile);
        System.out.println("解压成功~~");
*/
      /*  String str = "i like like like java do you like a java";
        byte[] bytes = str.getBytes();   ///用byte[] 保存字符串
        System.out.println("字符串的长度是 = " + bytes.length);  //输出字符串的长度

        byte[] huffmanCodeBytes = huffmanZip(bytes);
        System.out.println("压缩后的结果："+Arrays.toString(huffmanCodeBytes) +"\n压缩后字符串的长度为：" +huffmanCodeBytes.length);

        byte[] sourceByte = decode(huffmanCodes, huffmanCodeBytes);
        System.out.println("原来的字符串 = " + new String(sourceByte));*/



/*
        List<Node> nodes = getNodes(bytes);  //不妨ctrl+单击 getNodes方法试试
        System.out.println("nodes = " + nodes);

        //测试创建的哈夫曼树
        System.out.println("前序遍历");
        Node huffmanCodeRoot = createHuffmanCode(nodes);
        preOrder(huffmanCodeRoot);

        //测试是否生成对应的哈夫曼编码
        getCodes(huffmanCodeRoot,"",strBuilder);
        System.out.println("huffmanCodeRoot = " + huffmanCodes);

        //测试
        byte[] zip = zip(bytes, huffmanCodes);
        System.out.println("Arrays.toString(zip) = " + Arrays.toString(zip));*/

        //发送HuffmanCodeBytes 数组

    }

    /**
     * //封装前面的方法，便于调用
     *
     * @param bytes 字节
     * @return {@link byte[]}
     */
    private static byte[] huffmanZip(byte[] bytes){
        List<Node> nodes = getNodes(bytes);
        //根据nodes创建哈夫曼树
        Node huffmanCodeRoot = createHuffmanTree(nodes);
        //对应的哈夫曼编码
        getCodes(huffmanCodeRoot,"",strBuilder);
        //根据生成的哈夫曼编码，压缩得到压缩后的哈夫曼编码字节数组
        byte[] huffmanCodeByte = zip(bytes, huffmanCodes);
        return  huffmanCodeByte;
    }
    //编写一个方法，完成对压缩文件的解压
    /**
     *
     * @param zipFile 准备解压的文件
     * @param dstFile 将文件解压到哪个路径
     */
    public static void unZipFile(String zipFile, String dstFile) {

        //定义文件输入流
        InputStream is = null;
        //定义一个对象输入流
        ObjectInputStream ois = null;
        //定义文件的输出流
        OutputStream os = null;
        try {
            //创建文件输入流
            is = new FileInputStream(zipFile);
            //创建一个和  is关联的对象输入流
            ois = new ObjectInputStream(is);
            //读取byte数组  huffmanBytes
            byte[] huffmanBytes = (byte[])ois.readObject();
            //读取赫夫曼编码表
            Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();

            //解码
            byte[] bytes = decode(huffmanCodes, huffmanBytes);
            //将bytes 数组写入到目标文件
            os = new FileOutputStream(dstFile);
            //写数据到 dstFile 文件
            os.write(bytes);
        } catch (Exception e) {
            // TODO: handle exception
            System.out.println(e.getMessage());
        } finally {

            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e2) {
                // TODO: handle exception
                System.out.println(e2.getMessage());
            }

        }
    }


    /**
     * zip文件
     *
     * @param srcFile  目标文件
     * @param dstFile 输出文件
     */
    public static void zipFile(String srcFile, String dstFile) {

        //创建输出流
        OutputStream os = null;
        ObjectOutputStream oos = null;
        //创建文件的输入流
        FileInputStream is = null;
        try {
            //创建文件的输入流
            is = new FileInputStream(srcFile);
            //创建一个和源文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            //读取文件
            is.read(b);
            //直接对源文件压缩
            byte[] huffmanBytes = huffmanZip(b);
            //创建文件的输出流, 存放压缩文件
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的ObjectOutputStream
            oos = new ObjectOutputStream(os);
            //把 赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes); //我们是把
            //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
            //注意一定要把赫夫曼编码 写入压缩文件
            oos.writeObject(huffmanCodes);


        }catch (Exception e) {

            System.out.println(e.getMessage());
        }finally {
            try {
                is.close();
                oos.close();
                os.close();
            }catch (Exception e) {

                System.out.println(e.getMessage());
            }
        }

    }



    /**完成数据的解压
     *1、重写先转成 哈夫曼编码对应的二进制字符串
     *2、哈夫曼编码对应的二进制的字符串、  ==》 对照哈夫曼编码
     *编写一个方法，完成对压缩数据的解码
     *编写一个方法，完成对压缩数据的解码
     * @param huffmanCodes 赫夫曼编码表 map
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 就是原来的字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes, byte[] huffmanBytes) {

        //1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转成二进制的字符串
        for(int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            //判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length - 1);
            stringBuilder.append(byteToBitString(!flag, b));
        }
        //把字符串安装指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换，因为反向查询 a->100 100->a
        Map<String, Byte>  map = new HashMap<String,Byte>();
        for(Map.Entry<Byte, String> entry: huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }

        //创建要给集合，存放byte
        List<Byte> list = new ArrayList<>();
        //i 可以理解成就是索引,扫描 stringBuilder
        for(int  i = 0; i < stringBuilder.length(); ) {
            int count = 1; // 小的计数器
            boolean flag = true;
            Byte b = null;

            while(flag) {
                //1010100010111...
                //递增的取出 key 1
                if ( i+ count > stringBuilder.length()-1  && Integer.parseInt(String.valueOf(i)) == 0){
                    String key = stringBuilder.substring(i, stringBuilder.length());
                }
                String key = stringBuilder.substring(i, i+count);//i 不动，让count移动，指定匹配到一个字符
                b = map.get(key);
                if(b == null) {//说明没有匹配到
                    count++;
                }else {
                    //匹配到
                    flag = false;
                }
            }
            list.add(b);
            i += count;//i 直接移动到 count
        }
        //当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"
        //把list 中的数据放入到byte[] 并返回
        byte b[] = new byte[list.size()];
        for(int i = 0;i < b.length; i++) {
            b[i] = list.get(i);
        }
        return b;

    }


    /**
     * 将一个byte 转成一个二进制的字符串
     * @param b 传入的 byte
     * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位
     * @return 是该b 对应的二进制的字符串，（注意是按补码返回）
     */
    private static String byteToBitString(boolean flag, byte b) {
        //使用变量保存 b
        int temp = b; //将 b 转成 int
        //如果是正数我们还存在补高位
        if(flag) {
            temp |= 256; //按位与 256  1 0000 0000  | 0000 0001 => 1 0000 0001
        }
        String str = Integer.toBinaryString(temp); //返回的是temp对应的二进制的补码
        if(flag) {
            return str.substring(str.length() - 8);
        } else {
            return str;
        }
    }





    /**
     * 前序遍历哈夫曼树
     *
     * @param root 根节点
     */
    private static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("该二叉树为null");
        }
    }

    /**
     *
     *
     * @param bytes    原始的字符串对应的byte[] 数组，长度是20
     * @param huffmanCodes 生成的霍夫曼编码
     * @return {@link byte[]} 返回生成的哈夫曼编码处理后的byte[]数组
     * 01010001011011001111110011111110000010110000111011000111111010100110
     *///编写一个方法，将字符串对应的byte[] 数组，通过生成的哈夫曼编码表，返回一个哈夫曼编码，压缩后的byte[]
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {

        //1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历bytes 数组
        for(byte b: bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }

        //System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());

        //将 "1010100010111111110..." 转成 byte[]

        //统计返回  byte[] huffmanCodeBytes 长度
        //一句话 int len = (stringBuilder.length() + 7) / 8;
        int len;
        if(stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8;
        } else {
            len = stringBuilder.length() / 8 + 1;
        }
        //创建 存储压缩后的 byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;//记录是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) { //因为是每8位对应一个byte,所以步长 +8
            String strByte;
            if(i+8 > stringBuilder.length()) {//不够8位
                strByte = stringBuilder.substring(i);
            }else{
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte 转成一个byte,放入到 huffmanCodeBytes
            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
            index++;
        }
        return huffmanCodeBytes;
    }

    //将哈夫曼编码保存在map集合中
    static Map<Byte,String> huffmanCodes = new HashMap<Byte,String>();
    //拼接路径，用来存储某个叶子节点的路径
    static StringBuilder strBuilder = new StringBuilder();

    /**
     * 功能：将传入的node节点的所有叶子节点的哈夫曼编码得到，并放入到huffmanCodes集合中
     *
     * @param node       传入的节点
     * @param code       路径： 0是左子节点  1是右子节点
     * @param strBuilder 用于拼接路径
     */
    private static void getCodes(Node node, String code, StringBuilder strBuilder){
        StringBuilder strBuilder2 = new StringBuilder(strBuilder);
        //将code拼接到strBuilder2中
        strBuilder2.append(code);
        if (node != null){ //node ==null 空树不处理
            if (node.data == null){ //新创建的父节点没有data值，即： 非叶子节点
                //向左递归
                getCodes(node.left,"0",strBuilder2);
                //向右递归
                getCodes(node.right,"1",strBuilder2);
            }else {  //上面不是叶子节点，那么这里就是叶子节点
                //表示找到叶子节点,将其保存在map集合中
                huffmanCodes.put(node.data,strBuilder2.toString());
            }

        }
    }


    /**
     * 该方法的用处就是用list集合保存node节点
     * 而且每个节点中保存了 字符串中  每个字符的ASCII码值和出现次数（还排好序了）
     * 等下创建哈夫曼编码用到这个list集合的节点
     *
     * @param bytes 传入的字符串数组
     * @return 返回含有data  、weight 的节点
     */
    private static List<Node> getNodes(byte[] bytes){
        //创建一个list集合，用来保存node节点，命名为nodes
        List<Node> nodes = new ArrayList<>();
        //创建一个map集合，用来统计每个字符出现的次数，命名为map
        //k（bytes的ASCII码值）-v（字符出现的次数）
        Map<Byte, Integer> map = new HashMap<>();
        //遍历字符串数组
        for (byte data : bytes) {

           /*
           Integer count = map.get(data);
           if ( count == null){//k（bytes的ASCII码值）-v（字符出现的次数）如果字符出现的次数为null，就将其插入map集合，
                map.put(data,1);
            }else {
                map.put(data, count+1);//如果字符出现过了，就将其出现次数+1
            }*/

            map.merge(data, 1, Integer::sum);
            //不得不感叹一下JAVA的技术迭代的真快，上面6行的代码，这里一行就能说明清楚。
            //看不懂这个merge方法的，尝试 ctrl+单击 看看JDK源码，顺便看一下全英的注解

        }
        //使用Entry遍历map集合，将每个map集合中的元素插入list集合中
        for (Map.Entry<Byte,Integer> entry: map.entrySet()) {
            //list集合里面的是node节点，所以还需要用到map的k-v来构建node节点
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        //返回list集合
        return nodes;
    }

    /**
     * 创建霍夫曼编码
     * 取出list集合最小的两个节点创建一个二叉树，
     * 把取出来的节点删除，把创建的二叉树插入list集合，循环
     * 直到list集合只剩下一个节点，退出循环，该节点就是哈夫曼树的根节点
     *
     * @param nodes 节点
     * @return {@link Node}
     */
    private static Node createHuffmanTree(List<Node> nodes){
        while ( nodes.size() > 1){
            Collections.sort(nodes);

            //取出list集合最小的两个元素
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            //构建一个二叉树，不存放字符串，只存放权值。
            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            //把用过的节点移出集合
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //把新二叉树放回集合中
            nodes.add(parent);
        }
        return nodes.get(0);
    }
}
//创建带权值的节点类
class Node implements Comparable<Node>{
    Byte data;
    int weight;
    Node left;
    Node right;

    //构造器


    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }
    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left != null ){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
}
/*
我的实现步骤：
1、创建node节点类，包含data、weight、left、right、包含前序遍历的方法
2、主方法中添加str字符串，得到str对应的byte[] 数组
3、编写一个方法将准备好的byte[] 数组中每个字符统计出现次数和按大小排序
  1）通过hashmap将byte[]数组遍历，统计每个字符出现次数并排好序
  2）把每个键值对k-v以一个Node对象加入到List集合中
4、通过3得到的list集合创建哈夫曼树
  1）取出列表最小的两个值
  2）以这两个节点创建父节点（父节点的data值为null，只有权值weight）
  3）在list集合删除那两个节点，把父节点插入list集合、循环
  4）直到list只剩下一个节点，退出循环。哈夫曼树创建完成
5、主方法中调用前序遍历方法，测试是否正确
6、生成对应的哈夫曼编码表
  1)先创建一个map集合用来保存编码
  2）再创建一个stringBuilder用来拼接编码
  3）创建一个方法，将传入的node节点的所有叶子节点的哈夫曼编码得到，
  并放入到huffmanCodes集合中
  4）测试生成的编码是否成功
7、编写一个方法，将字符串对应的byte[] 数组，通过生成的哈夫曼编码表，
返回一个哈夫曼编码，压缩后的byte[]
8、编写一个方法，对哈夫曼编码进行解压
  1）字节转二进制字符串
  2）将二进制转换字符串
9、对文件压缩
  1）创建一个方法，传入输入流地址、输出流地址
  2）
10、对文件的解压
 */
```





### 9.9 二叉排序(BST)树

**二叉排序树介绍**

二叉排序树：

BST：（BinarySort（Search）Tree），对于二叉排序树的任何一个非叶子节点，要求左子节点比当前节点的值小，右子节点的值比当前的节点的值大。

**特别说明：**如果有相同的值，可以将该节点放在左子节点或者右子节点

#### 9.9.1 二叉排序树的创建与遍历

```java
package com.ldm.BinarySortTree;

/**
 * @author 梁东明
 * 2022/9/6
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        System.out.println("中序遍历二叉树");
        binarySortTree.infixOrder();
    }
}
class BinarySortTree {
    private Node root;

    public void infixOrder(){
        if (root !=null){
            root.infixOrder();
        }else {
            System.out.println("这是一个空树");
        }
    }
    public void add(Node node){
        if ( root == null){
            root = node;
        }else {
            root.add(node);
        }
    }

}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    /**
     * 添加节点的方法
     *
     * @param node 传入的节点
     */
    public void add(Node node){
        if ( node ==null){
            return;
        }
        if ( node.value < this.value){
            if (this.left == null){
                this.left = node;
            }else {
                this.left.add(node);
            }

        }else {
            if (this.right == null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
    }

    /**
     * 中缀遍历
     */
    public void infixOrder(){
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }

}
/*
实现步骤：
1、Node节点类
  1）创建value、left、right、构造器
  2）创建添加节点的方法
  3）中序遍历节点的方法
2、BinarySortTree类
  1）初始化root节点
  2）中序遍历
  3）添加节点的方法
3、main主方法
  1）创建数组
  2）创建二叉排序树的对象
  3）把数组插入二叉排序树
  4）调用中序遍历方法
 */
```

#### 9.9.2 二叉排序树删除节点

实现思路

```
三种情况：
1、删除叶子节点  2、删除只有一颗子树的非叶子节3、删除有左右子树的非叶子节点

第一种情况：
删除叶子节点
思路：
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）确定targetNode是parent的左子节点、还是右子节点
4）根据3的情况删除对应的节点
   左子节点：parent.left = null;
   右子节点：parent.right = null;
   
第二种情况：
删除只有一颗子树的节点
思路：
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）确定targetNode的子节点是左子节点还是右子节点
4）确定targetNode是parent的是左子节点还是右子节点
5）如果targetNode有左子节点
   (1)如果targetNode是parent的左子节点
       parent.left = targetNode.left
   (2)如果targetNode是parent的右子节点
       parent.right = targetNode.left

6）如果targetNode有右子节点
   (1)如果targetNode是parent的左子节点
       parent.left = targetNode.right
   (2)如果targetNode是parent的右子节点
       parent.right = targetNode.right
       
       
第三种情况
删除有两颗子树的节点
思路
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）从targetNode的右子节树找到最小的节点（或者左子树找到最大的节点）
4）用一个临时变量，将最小（最大）节点的值用temp保存
5）删除该最小（最大）节点
6）targetNode.value = temp
```



**代码实现：**

```java
 /**
     *1、返回以node为根节点的二叉排序树的最小节点的值
     *2、删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作当前二叉树的根节点）
     * @return 返回以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        //循环查找左子节点，直到找到最小值
        while (target.left != null){
            target = target.left;
        }
        //退出while循环后，最小值就找到了
        //把它删除了
        delNode(target.value);
        return target.value;

    }

    /**
     * 删除节点
     *
     * @param value 要删除节点的值
     */
    public void delNode(int value){
        if ( root == null){
            return;
        }else {
            //1、需要找到要删除的节点 targetNode
            Node targetNode = search(value);
            //如果没有找到就直接返回；
            if (targetNode == null){
                return;
            }
            //如果二叉排序树只有根节点，把根节点置null；
            if ( root.left == null && root.right ==null){
                root = null;
                return;
            }
            //找到要删除的节点的父节点
            Node parent = searchParent(value);
            //第一种情况：如果要删除的是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                //判断要删除的节点是其父节点左节点还是右节点
                if (parent.left != null && parent.left.value == value ){
                    parent.left = null;
                }else if (parent.right != null && parent.right.value == value){
                    parent.right = null;
                }
            } //第三种情况：如果要删除的节点有左右子树
            else if (targetNode.left != null && targetNode.right != null){
                int minValue = delRightTreeMin(targetNode.right);
                targetNode.value = minValue;
            }
            //第二种情况：如果要删除的节点有一个子树
            // 因为第二种情况的条件最复杂，所以用排除法先把第一第三种情况的条件判断，
            // 剩下的就是第二种情况的条件，直接不用if语句判断。无用的小知识又增加了！
            //你也可以把第二种情况的条件语句写出来,反正挺长的，你喜欢好了！
            //if( (targetNode.left != null && targetNode.right ==null) ||
            // (targetNode.right != null && targetNode.left == null) )
            else {
                //如果要删除的节点只有左子树
                if (targetNode.left != null){
                    if ( parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                }
                //如果要删除的节点只有右子树
                else {
                    if (parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.right;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }

                }


            }

        }
    }
```



**全部代码**

```java
package com.ldm.BinarySortTree;

/**
 * @author 梁东明
 * 2022/9/6
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {

        int[] arr = {7,3,10,12,5,1,9};
        BinarySortTree binarySortTree = new BinarySortTree();
        //遍历数组，将其插入到二叉排序树种
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        System.out.println("中序遍历二叉树");
        binarySortTree.infixOrder();

        //测试删除节点
        binarySortTree.delNode(10);
        System.out.println("删除节点后~");
        binarySortTree.infixOrder();
    }
}
class BinarySortTree {
    private Node root;

    /**
     * 搜索要删除的节点
     */
    public Node search(int value){
        if ( root == null){
            return null;
        }else {
            return root.search(value);
        }
    }

    /**
     * 搜索父节点
     */
    public Node searchParent(int value){
        if ( root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**
     *1、返回以node为根节点的二叉排序树的最小节点的值
     *2、删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作当前二叉树的根节点）
     * @return 返回以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        //循环查找左子节点，直到找到最小值
        while (target.left != null){
            target = target.left;
        }
        //退出while循环后，最小值就找到了
        //把它删除了
        delNode(target.value);
        return target.value;

    }

    /**
     * 删除节点
     *
     * @param value 要删除节点的值
     */
    public void delNode(int value){
        if ( root == null){
            return;
        }else {
            //1、需要找到要删除的节点 targetNode
            Node targetNode = search(value);
            //如果没有找到就直接返回；
            if (targetNode == null){
                return;
            }
            //如果二叉排序树只有根节点，把根节点置null；
            if ( root.left == null && root.right ==null){
                root = null;
                return;
            }
            //找到要删除的节点的父节点
            Node parent = searchParent(value);
            //第一种情况：如果要删除的是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                //判断要删除的节点是其父节点左节点还是右节点
                if (parent.left != null && parent.left.value == value ){
                    parent.left = null;
                }else if (parent.right != null && parent.right.value == value){
                    parent.right = null;
                }
            } //第三种情况：如果要删除的节点有左右子树
            else if (targetNode.left != null && targetNode.right != null){
                int minValue = delRightTreeMin(targetNode.right);
                targetNode.value = minValue;
            }
            //第二种情况：如果要删除的节点有一个子树
            // 因为第二种情况的条件最复杂，所以用排除法先把第一第三种情况的条件判断，
            // 剩下的就是第二种情况的条件，直接不用if语句判断。无用的小知识又增加了！
            //你也可以把第二种情况的条件语句写出来,反正挺长的，你喜欢好了！
            //if( (targetNode.left != null && targetNode.right ==null) ||
            // (targetNode.right != null && targetNode.left == null) )
            else {
                //如果要删除的节点只有左子树
                if (targetNode.left != null){
                    if ( parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                }
                //如果要删除的节点只有右子树
                else {
                    if (parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.right;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }

                }


            }

        }
    }
    /**
     * 中缀遍历
     */
    public void infixOrder(){
        if (root !=null){
            root.infixOrder();
        }else {
            System.out.println("这是一个空树");
        }
    }

    /**
     * 添加节点的方法
     *
     * @param node 节点
     */
    public void add(Node node){
        if ( root == null){
            root = node;
        }else {
            root.add(node);
        }
    }

}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    /**
     * 添加节点的方法
     *
     *
     * @param node 传入的节点
     */
    public void add(Node node){
        if ( node ==null){ //传入的节点为null，直接返回
            return;
        }
        if ( node.value < this.value){ //传入的节点小于当前节点，就放入当前节点的左子树
            if (this.left == null){ //当前节点的left为null，直接放入
                this.left = node;
            }else { //当前节点的left不为null，递归遍历当前节点的左子树，直到找到某个节点的left为null，插入传入的节点
                this.left.add(node);
            }

        }else { //传入的节点大于于当前节点，就放入当前节点的右子树
            if (this.right == null){//当前节点的right为null，直接放入
                this.right = node;
            }else {//当前节点的right不为null，递归遍历当前节点的左子树，直到找到某个节点的right为null，插入传入的节点
                this.right.add(node);
            }
        }
    }

    /**
     * 中缀遍历
     */
    public void infixOrder(){
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }

    /**
     * 搜索要删除的节点
     *
     * @param value 希望删除的节点的值
     * @return 找到就返回该节点，否则就返回null
     */
    public Node search(int value){
        //找到该节点就返回
        if (value == this.value){
            return this;
        }else if ( value < this.value ){
            if (this.left == null){ //树中没有该值的节点，就返回null
                return null;
            }
            return this.left.search(value);
        }else {
            if (this.right == null){//树中没有该值的节点，就返回null
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 搜索父节点
     *
     * @param value 希望删除的节点的值
     * @return 返回的是要删除的节点的父节点。如果没有就返回null
     */
    public Node searchParent(int value){
        //如果当前节点就是要删除的节点的父节点，返回
        if ( (this.left != null && this.left .value == value) ||
                (this.right != null && this.right .value == value)){
            return this;
        }else {
            //如果要查找的值小于当前节点的值，且当前节点的左子树不为null，就递归在左子树查找
            if (value < this.value && this.left != null){
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null){
                //如果要查找的值大于或等于当前节点的值，且当前节点的右子树不为null，就递归在右子树查找
                return this.right.searchParent(value);
            }else {
                return null;  //没有找到父节点
            }
        }
    }

}
/*
实现步骤：
1、Node节点类
  1）创建value、left、right、构造器
  2）创建添加节点的方法
  3）中序遍历节点的方法
2、BinarySortTree类
  1）初始化root节点
  2）中序遍历
  3）添加节点的方法
3、main主方法
  1）创建数组
  2）创建二叉排序树的对象
  3）把数组插入二叉排序树
  4）调用中序遍历方法

删除节点的思路：
三种情况：
1、删除叶子节点  2、删除只有一颗子树的非叶子节3、删除有左右子树的非叶子节点

第一种情况：
删除叶子节点
思路：
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）确定targetNode是parent的左子节点、还是右子节点
4）根据3的情况删除对应的节点
   左子节点：parent.left = null;
   右子节点：parent.right = null;

第二种情况：
删除只有一颗子树的节点
思路：
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）确定targetNode的子节点是左子节点还是右子节点
4）确定targetNode是parent的是左子节点还是右子节点
5）如果targetNode有左子节点
   (1)如果targetNode是parent的左子节点
       parent.left = targetNode.left
   (2)如果targetNode是parent的右子节点
       parent.right = targetNode.left

6）如果targetNode有右子节点
   (1)如果targetNode是parent的左子节点
       parent.left = targetNode.right
   (2)如果targetNode是parent的右子节点
       parent.right = targetNode.right


第三种情况
删除有两颗子树的节点
思路
1）需要找出要删除的节点 targetNode
2）找到targetNode的父节点parent
3）从targetNode的右子节树找到最小的节点（或者左子树找到最大的节点）
4）用一个临时变量，将最小（最大）节点的值用temp保存
5）删除该最小（最大）节点
6）targetNode.value = temp
 */
```





本次二叉搜索树教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=133&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 127-134p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



### 9.10 平衡(AVL)二叉树

引入

![image-20220907141018089](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907141018089.png)

**基本介绍**

1）平衡二叉树也叫平衡二叉搜索树（Self-balancingBinarySearchTree）又被称为AVL树，可以保证查询效率较高

2）具有以下特点：它是一颗空树或它的左右两个子树的高度差绝对值不超过1，并且左右两颗子树都是一颗平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树

```
左旋转分析：

数列{4，3，6，5，7，8}
            二叉排序树
                 4
               3   6
                 5    7
                        8
问题：当插入8时
rightHeight()-leftHeight() > 1,不再是一颗AVL树
可以进行左旋转处理使其变成AVL树
1）创建一个新的节点newNode（以根节点的值创建），创建一个新的节点
值等于当前根节点的值
2）//把新节点的左子树设置为当前节点的左子树
newNode.left = left;
3）//把新节点的右子树设置为当前节点的右子树的左子树
newNode.right = right.left;
4）//把当前节点的值转换成右子节点的值
value = right.value;
5）//把当前节点的右子树设置成右子树的右子树
right=right.right;
6）//把当前节点的左子树设置成新节点
left = newNode;
        左旋后的二叉排序树变成了AVL树
                   6
                4     7
             3     5    8


右旋转分析：
数列{10，12，8，9，7，6}
         二叉排序树
              10
            8    12
         7    9
       6
                      
问题：当插入6时
leftHeight()-rightHeight() > 1,不再是一颗AVL树
可以进行右旋转处理使其变成AVL树
1）创建一个新的节点newNode（以根节点的值创建），创建一个新的节点
值等于当前根节点的值
2）//把新节点的左子树设置为当前节点的左子树的右子树
newNode.left = left.right;
3）//把新节点的右子树设置为当前节点的右子树
newNode.right = right;
4）//把当前节点的值转换成左子节点的值
value = left.value;
5）//把当前节点的左子树设置成左子树左子树
left = left.left;
6）//把当前节点的右子树设置成新节点
right = newNode;      
        右旋后的二叉排序树变成AVL树
                  8
               7     10
             6     9    12
```

**左旋二叉搜索树、右旋二叉搜索树**

什么时候开始左旋？ 什么时候开始右旋？当然是根节点的左右子树的高度差大于1

**rightHeight()-leftHeight() > 1的时候左旋**

**leftHeight()-rightHeight() > 1的时候右旋**



所以，无论左旋还是右旋，还得要求出树的左右子树的高度

**代码实现**

```java
 /**
     * 返回左子树的高度
     */
    public int getLeftHeight(){
        if (left == null){
            return 0;
        }
        return left.getHeight();

    }

    /**
     * 返回右子树的高度
     */
    public int getRightHeight(){
        if (right == null){
            return 0;
        }
        return  right.getHeight();

    }

    /**
     * 返回树的高度
     */
    public int getHeight(){

        return Math.max(left == null ? 0 : left.getHeight(), right == null ? 0 : right.getHeight()) + 1;
    }

```

**左旋代码**

```java

    /**
     * 左旋转
     */
    public void leftRotate(){
        //创建新节点，以根节点的值
        Node newNode = new Node(value);
        //把新节点的左子树设置为当前节点的左子树
        newNode.left = left;
        //把新节点的右子树设置为当前节点的右子树的左子树
        newNode.right = right.left;
        //把当前节点的值转换成右子节点的值
        value = right.value;
        //把当前节点的右子树设置成右子树的右子树
        right=right.right;
        //把当前节点的左子树设置成新节点
        left = newNode;


    }
```

右旋代码

```java
/**
     * 右旋转
     */
    public void rightRotate() {
        //创建新节点，以根节点的值
        Node newNode = new Node(value);
        //创建一个新的节点newNode（以根节点的值创建），创建一个新的节点
        //值等于当前根节点的值
        //把新节点的左子树设置为当前节点的左子树的右子树
        newNode.left = left.right;
        //把新节点的右子树设置为当前节点的右子树
        newNode.right = right;
        //把当前节点的值转换成左子节点的值
        value = left.value;
        //把当前节点的左子树设置成左子树左子树
        left = left.left;
        //把当前节点的右子树设置成新节点
        right = newNode;
    }
```



**AVL实现双旋**

有时候，符合左旋或者符合右旋的二叉搜索树的结构，旋转之后不一定能实现AVL树。所以需要左旋配合右旋使用  或者右旋配合左旋使用。

如下图例子

![image-20220907133604044](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907133604044.png)

这是因为 7 这个节点为根节点的树的右子节点高度大于它的左子树的高度

```
        7
      6  8
          9
问题分析：
1、当符合右旋的条件时
2、如果它的左子树的右子节点高度大于它的左子树的高度
3、先对当前节点的左节点（7为根节点）进行左旋
       8
     7   9
    6
4、再对当前节点（10）进行右旋的操作即可

            双旋得到的AVL树
                  8
                7   10
              6    9   11
             
```

**添加二叉树节点的时候调用左右旋**

```java
 /**
     * 添加节点的方法
     *
     *
     * @param node 传入的节点
     */
    public void add(Node node){
        if ( node ==null){ //传入的节点为null，直接返回
            return;
        }
        if ( node.value < this.value){ //传入的节点小于当前节点，就放入当前节点的左子树
            if (this.left == null){ //当前节点的left为null，直接放入
                this.left = node;
            }else { //当前节点的left不为null，递归遍历当前节点的左子树，直到找到某个节点的left为null，插入传入的节点
                this.left.add(node);
            }

        }else { //传入的节点大于于当前节点，就放入当前节点的右子树
            if (this.right == null){//当前节点的right为null，直接放入
                this.right = node;
            }else {//当前节点的right不为null，递归遍历当前节点的左子树，直到找到某个节点的right为null，插入传入的节点
                this.right.add(node);
            }
        }
        //rightHeight()-leftHeight() > 1,不再是一颗AVL树
        //可以进行旋转处理使其变成AVL树
        if ( getRightHeight() - getLeftHeight() > 1 ){
            //如果它的右子树 的左子树的高度大于左子树
            if (right != null && right.getLeftHeight() > right.getRightHeight()){
                //先对当前节点的右节点（右子树）-》右旋
                right.rightRotate();
                //再对当前节点进行右旋
                leftRotate();
            }else {
                leftRotate();
            }
            return; //这个步骤必须要
        }
        //leftHeight()-rightHeight() > 1,不再是一颗AVL树
        //可以进行旋转处理使其变成AVL树
        if (  getLeftHeight()-getRightHeight()  > 1 ){
            //如果它的左子树  的右子树的高度左子树
            if (left != null && left.getRightHeight() > left.getLeftHeight()){
                //先对当前节点的左节点（左子树）-》左旋
                left.leftRotate();
                //再对当前节点进行右旋
                rightRotate();
            }else {
                rightRotate();
            }
        }
    }

```

#### 完整代码

```java
package com.ldm.AVL;

/**
 * @author 梁东明
 * 2022/9/7
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr= {4,3,6,5,7,8};
        //int[] arr = {10,12,8,9,7,6};
        int[]  arr = {10,11,7,6,8,9};

        AVLTree avlTree = new AVLTree();

        for (int i = 0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }
        System.out.println("中序遍历~");
        avlTree.infixOrder();
        System.out.println("树的高度是：" + avlTree.getRoot().getHeight());
        System.out.println("左子树的高度是：" + avlTree.getRoot().getLeftHeight());
        System.out.println("右子树的高度是：" + avlTree.getRoot().getRightHeight());
        System.out.println("当前根节点是：" + avlTree.getRoot());

    }
}
class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }

    /**
     * 搜索要删除的节点
     */
    public Node search(int value){
        if ( root == null){
            return null;
        }else {
            return root.search(value);
        }
    }

    /**
     * 搜索父节点
     */
    public Node searchParent(int value){
        if ( root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**
     *1、返回以node为根节点的二叉排序树的最小节点的值
     *2、删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作当前二叉树的根节点）
     * @return 返回以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node){
         Node target = node;
        //循环查找左子节点，直到找到最小值
        while (target.left != null){
            target = target.left;
        }
        //退出while循环后，最小值就找到了
        //把它删除了
        delNode(target.value);
        return target.value;

    }

    /**
     * 删除节点
     *
     * @param value 要删除节点的值
     */
    public void delNode(int value){
        if ( root == null){
            return;
        }else {
            //1、需要找到要删除的节点 targetNode
            Node targetNode = search(value);
            //如果没有找到就直接返回；
            if (targetNode == null){
                return;
            }
            //如果二叉排序树只有根节点，把根节点置null；
            if ( root.left == null && root.right ==null){
                root = null;
                return;
            }
            //找到要删除的节点的父节点
            Node parent = searchParent(value);
            //第一种情况：如果要删除的是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                //判断要删除的节点是其父节点左节点还是右节点
                if (parent.left != null && parent.left.value == value ){
                    parent.left = null;
                }else if (parent.right != null && parent.right.value == value){
                    parent.right = null;
                }
            } //第三种情况：如果要删除的节点有左右子树
            else if (targetNode.left != null && targetNode.right != null){
                int minValue = delRightTreeMin(targetNode.right);
                targetNode.value = minValue;
            }
            //第二种情况：如果要删除的节点有一个子树
            // 因为第二种情况的条件最复杂，所以用排除法先把第一第三种情况的条件判断，
            // 剩下的就是第二种情况的条件，直接不用if语句判断。无用的小知识又增加了！
            //你也可以把第二种情况的条件语句写出来,反正挺长的，你喜欢好了！
            //if( (targetNode.left != null && targetNode.right ==null) ||
            // (targetNode.right != null && targetNode.left == null) )
            else {
                //如果要删除的节点只有左子树
                if (targetNode.left != null){
                    if ( parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                }
                //如果要删除的节点只有右子树
                else {
                    if (parent != null){
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value){
                            parent.left = targetNode.right;
                        } //如果targetNode是parent的右子节点
                        else if (parent.right.value == value){
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }

                }


            }

        }
    }
    /**
     * 中缀遍历
     */
    public void infixOrder(){
        if (root !=null){
            root.infixOrder();
        }else {
            System.out.println("这是一个空树");
        }
    }

    /**
     * 添加节点的方法
     *
     * @param node 节点
     */
    public void add(Node node){
        if ( root == null){
            root = node;
        }else {
            root.add(node);
        }
    }

}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 返回左子树的高度
     */
    public int getLeftHeight(){
        if (left == null){
            return 0;
        }
        return left.getHeight();

    }

    /**
     * 返回右子树的高度
     */
    public int getRightHeight(){
        if (right == null){
            return 0;
        }
        return  right.getHeight();

    }

    /**
     * 返回树的高度
     */
    public int getHeight(){

        return Math.max(left == null ? 0 : left.getHeight(), right == null ? 0 : right.getHeight()) + 1;
    }

    /**
     * 左旋转
     */
    public void leftRotate(){
        //创建新节点，以根节点的值
        Node newNode = new Node(value);
        //把新节点的左子树设置为当前节点的左子树
        newNode.left = left;
        //把新节点的右子树设置为当前节点的右子树的左子树
        newNode.right = right.left;
        //把当前节点的值转换成右子节点的值
        value = right.value;
        //把当前节点的右子树设置成右子树的右子树
        right=right.right;
        //把当前节点的左子树设置成新节点
        left = newNode;
    }
    /**
     * 右旋转
     */
    public void rightRotate() {
        //创建新节点，以根节点的值
        Node newNode = new Node(value);
        //创建一个新的节点newNode（以根节点的值创建），创建一个新的节点
        //值等于当前根节点的值
        //把新节点的左子树设置为当前节点的左子树的右子树
        newNode.left = left.right;
        //把新节点的右子树设置为当前节点的右子树
        newNode.right = right;
        //把当前节点的值转换成左子节点的值
        value = left.value;
        //把当前节点的左子树设置成左子树左子树
        left = left.left;
        //把当前节点的右子树设置成新节点
        right = newNode;
    }

        @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    /**
     * 添加节点的方法
     *
     *
     * @param node 传入的节点
     */
    public void add(Node node){
        if ( node ==null){ //传入的节点为null，直接返回
            return;
        }
        if ( node.value < this.value){ //传入的节点小于当前节点，就放入当前节点的左子树
            if (this.left == null){ //当前节点的left为null，直接放入
                this.left = node;
            }else { //当前节点的left不为null，递归遍历当前节点的左子树，直到找到某个节点的left为null，插入传入的节点
                this.left.add(node);
            }

        }else { //传入的节点大于于当前节点，就放入当前节点的右子树
            if (this.right == null){//当前节点的right为null，直接放入
                this.right = node;
            }else {//当前节点的right不为null，递归遍历当前节点的左子树，直到找到某个节点的right为null，插入传入的节点
                this.right.add(node);
            }
        }
        //rightHeight()-leftHeight() > 1,不再是一颗AVL树
        //可以进行旋转处理使其变成AVL树
        if ( getRightHeight() - getLeftHeight() > 1 ){
            //如果它的右子树 的左子树的高度大于左子树
            if (right != null && right.getLeftHeight() > right.getRightHeight()){
                //先对当前节点的右节点（右子树）-》右旋
                right.rightRotate();
                //再对当前节点进行右旋
                leftRotate();
            }else {
                leftRotate();
            }
            return; //这个步骤必须要
        }
        //leftHeight()-rightHeight() > 1,不再是一颗AVL树
        //可以进行旋转处理使其变成AVL树
        if (  getLeftHeight()-getRightHeight()  > 1 ){
            //如果它的左子树  的右子树的高度左子树
            if (left != null && left.getRightHeight() > left.getLeftHeight()){
                //先对当前节点的左节点（左子树）-》左旋
                left.leftRotate();
                //再对当前节点进行右旋
                rightRotate();
            }else {
                rightRotate();
            }
        }
    }

    /**
     * 中缀遍历
     */
    public void infixOrder(){
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }

    /**
     * 搜索要删除的节点
     *
     * @param value 希望删除的节点的值
     * @return 找到就返回该节点，否则就返回null
     */
    public Node search(int value){
        //找到该节点就返回
        if (value == this.value){
            return this;
        }else if ( value < this.value ){
            if (this.left == null){ //树中没有该值的节点，就返回null
                return null;
            }
            return this.left.search(value);
        }else {
            if (this.right == null){//树中没有该值的节点，就返回null
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 搜索父节点
     *
     * @param value 希望删除的节点的值
     * @return 返回的是要删除的节点的父节点。如果没有就返回null
     */
    public Node searchParent(int value){
        //如果当前节点就是要删除的节点的父节点，返回
        if ( (this.left != null && this.left .value == value) ||
                (this.right != null && this.right .value == value)){
            return this;
        }else {
            //如果要查找的值小于当前节点的值，且当前节点的左子树不为null，就递归在左子树查找
            if (value < this.value && this.left != null){
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null){
                //如果要查找的值大于或等于当前节点的值，且当前节点的右子树不为null，就递归在右子树查找
                return this.right.searchParent(value);
            }else {
                return null;  //没有找到父节点
            }
        }
    }

}
```



本次平衡二叉树教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=141&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 135-141p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

### 9.11 多路查找树

   引出

二叉树的操作效率较高，但是也存在问题

![image-20220907143050583](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907143050583.png)

1、二叉树需要加载到内存的，如果二叉树的节点少，没什么问题，但是如果二叉树的节点很多则会引出很多问题

​     1）在构建二叉树时，需要多次进行i/0操作（海量数据存储在数据库中或者文件中），节点海量。构建二叉树时，速度有影响

​      2）节点海量，也会造成二叉树高度很大，会降低操作速度。

#### 9.11.1 二叉树与B树

**多叉树**

1）在二叉树中，每个节点有数据项，最多有两个子节点，如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）

2）多叉树通过重新组织节点，减少树的高度，对二叉树进行优化

**B树**

B树通过重新组织节点，减低树的高度，并且减少i/o读写次数来提升效率

![image-20220907144212823](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907144212823.png)

1）图B树通过重新组织节点，减低树的高度

2）文件系统及数据库系统的设计者利用磁盘预读原理，将一个节点的大小等于一个页（页的大小通过为4k）这样每个节点只需要一次i/o就可以完全载入

3）将树的度M设置为1024，在600亿个元素中最多只需要4次i/o操作就可以读取到想要的元素，B树（）广泛应用于文件存储系统以及数据库系统中



**2-3树基本介绍**

1）2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）

2）有两个子节点的节点叫二节点，二节点要么没有子节点要么有两个子节点

3）有三个子节点的节点叫三节点，三节点要么没有子节点要么有三个子节点

4）2-3树就是由二节点和三节点构成的树

![image-20220907152536926](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907152536926.png)





#### 9.11.2 B树、B+树和B*树

**B树**



 B-tree树即B树，B即Balanced，实际上B-tree就是指B树

**B树说明：**

1）B树的阶：节点的最多子节点个数，比如2-3树的阶就是3，2-3-4树的阶就是4

2）B树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中就结束，否则进入查询关键字所属范围的儿子节点，循环-直到对应的儿子指针为null，或已经时叶子节点

3）关键字集合分布在整棵树中、即叶子节点和非叶子节点都存放数据

4）搜索有可能在非叶子节点结束

5）其搜索性能等价于关键字全集内做一次二分查找



![image-20220907155138858](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907155138858.png)



**B+树的说明**

B+树是B树的变体，也是一种多路搜索树



1）B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中(B树可以在非叶子结点命中）,其性能也等价于在关键字全集做一次二分查找

2）所有关键字都出现在叶子结点的链表中(即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字(数据)恰好是有序的。

3）不可能在非叶子结点命中

4）非叶子结点相当于是叶子结点的索引(稀疏索引)叶子结点相当于是存储(关键字）数据的数据层

5）更适合文件索引系统
6）B树和B+树各有自己的应用场景,不能说B+树完全比B树好，反之亦然.

![image-20220907160510362](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907160510362.png)

**B*树介绍**

B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针

![image-20220907161044901](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907161044901.png)



## 第10章 图

### 10.1 图的常用概念

1）顶点（vertex）

2）边（edge）

3）路径

4）无向图

5）有向图

6）带权图

- 无向图

![image-20220907161708631](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907161708631.png)

- 有向图和带权图

![image-20220907161950791](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907161950791.png)

### 10.2 图的表示方式

#### 10.2.1 二维数组（邻接矩阵）

**邻接矩阵**

表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row（行）和col（列）表示1......n个点

![image-20220907162359802](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907162359802.png)

#### 10.2.2 链表（邻接表）

**邻接表**

1）邻接表需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间上一定损失

2）邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费 邻接表是由：数组+链表组成

![image-20220907164536576](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907164536576.png)



### 10.3 图的创建

**要求**

![image-20220907165017602](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907165017602.png)

**代码实现**



```java
package com.ldm.graph;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/7
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class Graph {
    private ArrayList<String> vertexList;  //存储顶点
    private int[][] edges;  //存储图对应的邻接矩阵
    private int numOfEdges;  //表示对应的数目

    public static void main(String[] args) {
        int n = 5;

        String VertexValue[] = {"A","B","C","D","E"};
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String str: VertexValue) {
            graph.insertVertex(str);
        }
        //添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        graph.showGraph();


    }
    //构造器

    public Graph(int n) {
        //初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<>();
        numOfEdges = 0;
    }
    //返回节点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }
    //得到的边数
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回结点i对应下标的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //遍历显示矩阵
    public void showGraph(){
        for (int[] link : edges){
            System.out.println(Arrays.toString(link));
        }
    }

    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /**
     * 添加边
     *
     * @param v1     v1 第一个顶点
     * @param v2     v2 第二个顶点
     * @param weight 权值为1 则赋边
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}

```



### 10.4 图的深度优先遍历

**图的遍历介绍**

所谓的遍历，即是对节点的访问

**深度优先DFS遍历基本思想**

图的深度优先搜索（Depth First Search）

1）深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略是：首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始节点，访问它的第一邻接结点。可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

2）我们可以看到，这样的访问策略是优先纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

3）显然：深度优先搜索是一个递归的过程



**深度优先遍历算法步骤**

1）访问初始结点v，并标记结点v为已访问。

2）查找结点v的第一邻接结点w

3）若w存在，则继续执行4，如果w不存在，则返回第1步，将从v的下一个结点继续

4）若w未被访问，对w进行深度优先遍历递归（即把w当作另外一个v，然后进行步骤123）

5）查找结点v的w邻接结点的下一个邻接结点，转到步骤3

![image-20220907233157553](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220907233157553.png)

**代码实现**



```java
//得到第一个邻接结点的下标w
    public int getFirstNeighbor(int index){
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0){
                return j;
            }
        }
        return -1;
    }
    //根据前一个邻接结点的下标得到下一个邻接结点的下标
    public int getNextNeighbor(int v1, int v2){
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if (edges[v1][j] > 0){
                return j;
            }
        }
        return -1;
    }

    /**
     *深度优先遍历
     * @param isVisited ,记录某个结点是否被访问
     * @param i         某个结点的下标
     */
    public void dfs(boolean[] isVisited, int i){
        //输出访问的结点
        System.out.print( getValueByIndex(i)+"->");
        //将被访问过的结点置为已访问
        isVisited[i] = true;
        //查找结点i的第一个邻接结点
        int w = getFirstNeighbor(i);
        //如果存在就继续访问
        while (w != -1){
            //还需要判断这个结点是否被访问过
            if ( ! isVisited [w] ){
                //没被访问过，那我们就递归,
                dfs(isVisited,w);
            }
            //如果已经被访问过了，就对w的下一个邻接结点进行查找
            w = getNextNeighbor(i,w);
        }
    }
    //对dfs重载，遍历所有的结点
    public void dfs(){
        //遍历所有的结点，进行dfs回溯
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }

```



### 10.5 图的广度优先遍历

**广度优先遍历基本思想**

图的广度优先搜索（BroadFirstSearch)

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列保持访问过的结点的顺序。以便按照这个顺序来访问这些结点的邻接结点。

**广度优先遍历算法步骤**

1）访问初始节点并标记v为已访问。

2）结点v进入duilie

3）当队列非空，继续执行，否则算法结束

4）出队列，取得队头结点u

5）查找结点u的第一个邻接结点w。

6）若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤

​       1、若结点w尚未被访问，则访问结点w并标记已访问

​        2、结点w入队

​        3、查找结点u的j继w邻接结点后的下一个邻接结点w，转到步骤6.

```java
//对一个结点进行广度优先遍历
    public void bfs(boolean[] isVisited, int i){
        int u;  //队头结点的suoyin
        int w;  //邻接结点w
        //创建队列
        LinkedList queue = new LinkedList<>();
        //访问结点
        System.out.print(getValueByIndex(i)+"=>");
        //标记为已访问
        isVisited[i] = true;
        //将结点接入队列
        queue.addLast(i);
        //如果队头元素不为null，就继续遍历
        while ( !queue.isEmpty()){
            //取出队头的结点下标
            u = (Integer) queue.removeFirst();
            //得到u的下一个结点w
            w = getFirstNeighbor(u);
            while ( w != -1){
                //判断是否访问过
                if (!isVisited[w]){
                    //没被访问过就访问
                    System.out.print(getValueByIndex(w)+"=>");

                    //标记为已访问
                    isVisited[w] = true;
                    //入队列
                    queue.addLast(w);
                }
                w= getNextNeighbor(u,w);
            }

        }
    }
    //对bfs重载
    public void bfs(){
        isVisited = new boolean[5];
        //遍历所有的结点，进行dfs回溯
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }


```



### 10.6完整代码



```java
package com.ldm.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

/**
 * @author 梁东明
 * 2022/9/7
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class Graph {
    private ArrayList<String> vertexList;  //存储顶点
    private int[][] edges;  //存储图对应的邻接矩阵
    private int numOfEdges;  //表示对应的数目
    //定义给数组boolean[],记录某个结点是否被访问
    private boolean[] isVisited;

    public static void main(String[] args) {
        int n = 5;

        String VertexValue[] = {"A","B","C","D","E"};
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String str: VertexValue) {
            graph.insertVertex(str);
        }
        //添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        graph.showGraph();

        System.out.println("深度遍历");
        graph.dfs();
        System.out.println();
        System.out.println("广度遍历");
        graph.bfs();


    }
    //构造器
    public Graph(int n) {
        //初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<>();
        numOfEdges = 0;

    }
    //得到第一个邻接结点的下标w
    public int getFirstNeighbor(int index){
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0){
                return j;
            }
        }
        return -1;
    }
    //根据前一个邻接结点的下标得到下一个邻接结点的下标
    public int getNextNeighbor(int v1, int v2){
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if (edges[v1][j] > 0){
                return j;
            }
        }
        return -1;
    }

    /**
     *深度优先遍历
     * @param isVisited ,记录某个结点是否被访问
     * @param i         某个结点的下标
     */
    public void dfs(boolean[] isVisited, int i){
        //输出访问的结点
        System.out.print( getValueByIndex(i)+"->");
        //将被访问过的结点置为已访问
        isVisited[i] = true;
        //查找结点i的第一个邻接结点
        int w = getFirstNeighbor(i);
        //如果存在就继续访问
        while (w != -1){
            //还需要判断这个结点是否被访问过
            if ( ! isVisited [w] ){
                //没被访问过，那我们就递归,
                dfs(isVisited,w);
            }
            //如果已经被访问过了，就对w的下一个邻接结点进行查找
            w = getNextNeighbor(i,w);
        }
    }
    //对dfs重载，遍历所有的结点
    public void dfs(){
        isVisited = new boolean[5];
        //遍历所有的结点，进行dfs回溯
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }
    //对一个结点进行广度优先遍历
    public void bfs(boolean[] isVisited, int i){
        int u;  //队头结点的suoyin
        int w;  //邻接结点w
        //创建队列
        LinkedList queue = new LinkedList<>();
        //访问结点
        System.out.print(getValueByIndex(i)+"=>");
        //标记为已访问
        isVisited[i] = true;
        //将结点接入队列
        queue.addLast(i);
        //如果队头元素不为null，就继续遍历
        while ( !queue.isEmpty()){
            //取出队头的结点下标
            u = (Integer) queue.removeFirst();
            //得到u的下一个结点w
            w = getFirstNeighbor(u);
            while ( w != -1){
                //判断是否访问过
                if (!isVisited[w]){
                    //没被访问过就访问
                    System.out.print(getValueByIndex(w)+"=>");

                    //标记为已访问
                    isVisited[w] = true;
                    //入队列
                    queue.addLast(w);
                }
                w= getNextNeighbor(u,w);
            }

        }
    }
    //对bfs重载
    public void bfs(){
        isVisited = new boolean[5];
        //遍历所有的结点，进行dfs回溯
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }



    //返回节点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }
    //得到的边数
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回结点i对应下标的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //遍历显示矩阵
    public void showGraph(){
        for (int[] link : edges){
            System.out.println(Arrays.toString(link));
        }
    }

    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /**
     * 添加边
     *
     * @param v1     v1 第一个顶点
     * @param v2     v2 第二个顶点
     * @param weight 权值为1 则赋边
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}

```

、

本次图 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=146&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 146-152p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

# 算法

## 第1章 分治算法

###  1.1 二分查找(非递归)

**前面我们使用过二分查找算法，这我们使用非递归的方法**



1）二分查找只适用于从有序的数列中进行查找（比如数字和字母等），将数列排序后再进行查找

2）二分查找的运行时间为对数时间o(log2n),即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列（100个数，即n=100）中寻找目标数30，则需要查找步数为log2 100），即最多需要查找7次



**代码实现**

```java
package com.ldm.binarySearchNoRecursion;

/**
 * @author 梁东明
 * 2022/9/10
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 * 二分查找非递归算法
 */
public class BinarySearchNoRecur {
    public static void main(String[] args) {
        int[] arr = { 1,3,5,7,9,12,15,18,21,24,27};
        int i = binarySearch(arr, 24);
        if ( i == -1){
            System.out.println("数组中没有该元素");
        }else {
            System.out.println("1在数组中的索引是 = " + i);
        }
    }

    /**
     * 二分查找非递归
     *
     * @param arr    传进来的有序数组
     * @param target 目标元素
     * @return int   返回该目标元素的下标，没有就返回-1
     */
    public static int binarySearch(int[] arr, int target){
        int left = 0;
        int right = arr.length - 1;
        while (left <= right){  //开始查找
            int mid = (left + right) / 2;
            if (arr[mid] == target){//找到就直接返回下标
                return mid;
            }else if (arr[mid] > target){//说明目标元素在数组的左边，在左边继续查找
                right = mid - 1 ;
            }
            else if (arr[mid] < target){//说明目标元素在数组的右边，在右边继续查找
                left = mid + 1;
            }
        }
        //说明数组中没有该目标，直接返回-1
        return -1;
    }
}

```



### 1,2 分治算法的基本介绍

**分治算法的基本介绍**

1）分治法是一种很重要的算法，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多相同或相似的子问题。。。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并，这个技巧是很多高效算法的基础，如：排序算法（快速排序归并排序）

2）分治算法可以求解的一些经典问题

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- 合并排序
- 快速排序
- 线性时间选择
- 最接近点对问题
- 循环赛日程表
- 汉诺塔

**分治算法的基本步骤**

分治算法在每一层递归上都有三个步骤：

1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

2)解决：若子问题规模较小而容易被解决则直接解决，否则递归地解各个子问题

3）合并：将各个子问题得解合并成原问题得解

### 1.3 汉诺塔



**分治算法最佳实践**

汉诺塔的传说：

汉诺塔问题是源于印度一个古老传说的益智游戏。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序攥着64片黄金圆盘，大梵天命令婆罗门把圆盘从下面开始按照大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上面不能放大圆盘，在三根柱子之间一次只能移动一个圆盘



![在这里插入图片描述](https://img-blog.csdnimg.cn/638d775aa1614202a22ec07453cd4baf.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/377a9917ecaf4430809f419f8fc214ee.png)



**代码实现**

```java
package com.ldm.dac;

/**
 * @author 梁东明
 * 2022/9/11
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class hanoiTower {
    public static void main(String[] args) {
        HanoiTower(5,'A','B','C');
    }

    //汉诺塔移动方案
    public static void HanoiTower(int num, char a, char b, char c){
        
        //如果只有一个盘，直接移动
        if (num == 1){
            System.out.println("第1个盘从 " + a +"->" + c);
        }else { //如果不止一个盘，我们总是可以看作是两个盘，
            //最上面的盘是 num - 1
            //最下面的盘是 num
            //先把最上面的盘从A移动到B。移动过程使用到C，递归
            HanoiTower(num - 1,a ,c,b);
            //把最下面的盘从A移动到C 。
            System.out.println("第" +num+"个盘从 " + a +"->"+c);
            //再把B上的盘移动到C盘，移动过程使用到A，递归
            HanoiTower(num -1,b , a, c);

        }
    }
}

```

本次分治算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=146&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 153-156p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

## 第2章 动态规划

### 2.1 动态规划基本介绍

1）动态规划（Dynamic Programming）算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2）动态规划算法与分治算法类似，其基本思想也还是将待求解问题分解成若干个小问题，先求解子问题，然后从这些子问题的解得到原问题的解

3）与分治算法不同的是：以用于用动态规划求解的问题，经分解得到子问题往往不是相互独立的（即：下一个子阶段的求解是建立在上一个子阶段的基础上。进行进一步的求解）

4）动态规划是可以通过填表的方式逐步推导，得到最优解

### 2.2 0-1背包问题

![image-20220911213639350](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220911213639350.png)

3）思路分析和图解

- 背包问题主要是指一个给定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分为0-1背包和完全背包（完全背包指的是：每种物品都有无限件可用）
- 这里的问题属于0-1背包，即每个物品最多放一个，而无限背包可以转换成0-1背包



**思路分析：**

算法的主要思想：利用动态规划来解决，每次遍历到第i个物品，根据w[i] 和v[i] 来确定是否需要将该物品放入到背包中，即对于给定的n个物品，设v[i] 、w[i]分别为第i个物品的价值和重量，C为背包的容量，再令v[i] [j] 表示在前i个物品中能够装入容量为j的背包中的最大价值。则有如下结果

-  v[i] [0] = v[0] [j] = 0;

  - 规定不能装任何东西的时候，或者背包的容量为0的时候，最大价值就是0 

- 当w[i] > j ;   v[i] [j] = v[i-1] [j];

  - //当准备加入新增的物品的容量大于当前背包的容量时，此时背包的最大价值就是加入该物品之前，其他已经放入到背包中的最大价值

- 当j > =w[i] ;   v[i] [j] = max{v[i-1] [j], v[i] + v[i-1] [ j -w[i] ] + v[i] }

  - //当准备加入的新增物品的容量小于等于当前背包的容量
  - 3.如果准备加入的物品的重量比背包包容量小的话，有两种选择 1、把当前物品放入背包  2、不把当前物品放入背包，这两种选择取决于 放入当前物品后是否会导致背包容量溢出，**如果溢出的话，就比较当前背包的价值与溢出的物品的 价值大小，**如果溢出前物品的价值大，就不放入当前物品。 如果溢出前的物品价值小，就放入当前物品，把之前放入的物品取出。  **如果不溢出的话，把当前物品也加入到背包中，之前的物品也不需要取出。**

- //装入的方式：

  j ：背包的容量

  w[i] : 第i物品的重量

  v[i] :  第i物品的价值

​       v[i-1] [j] :第i个物品**之前**的装入最大价值

​       v[i-1] [j - w[i]] : 装入i-1个物品，到剩余空间的最大值

![image-20220911220248978](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220911220248978.png)



**代码实现**

```java
package com.ldm.dynamic;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/11
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 *
 * 0-1背包问题
 *
 */
public class KnapSackProblem {
    public static void main(String[] args) {
        int[] w = {1,4,3}; //物品的重量
        int[] val = {1500,3000,2000};//物品的价值

        int m = 4; //背包的容量
        int n = val.length; //物品的个数

        //创建二维数组表示 前i个商品能够装入容量为j的背包的最大价值
        int[][] v = new int[n+1][m+1];
        //为了记录物品的放置情况，再定义一个二维数组
        int[][] path = new int[n+1][m+1];




        //规定不能装任何东西的时候，或者背包的容量为0的时候，最大价值就是0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0;  //第一列设置为0（背包的容量为0的时候）
        }
        /*
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0; //第一行设置为0（背包不装任何东西的时候）
        }
        */
        //上面三行代码可以用这一行代码代替（CTRL + 点击 看看源码，这样你就懂了）
        //很多方法，都不需要我们重复造轮子，JDK自己就已经封装好了，我们直接调用就行了
        Arrays.fill(v[0], 0);//第一行设置为0（背包不装任何东西的时候）


        //动态规划
        for (int i = 1; i < v.length; i++) { //不处理第一行，因为上两步已经把它们置为0了
            for (int j = 1; j < v[i].length; j++) { //不出来第一列，

                //当准备加入新增的物品的容量大于当前背包的容量时，
                //此时背包的最大价值就是加入该物品之前，其他已经放入到背包中的最大价值
                 if ( w[i-1] > j){ //本来应该是w[i] > j 的，但是我们的程序是从1开始的，所以要减1
                     v[i][j] = v[i-1][j];
                 }
                //3.如果准备加入的物品的重量比背包包容量小的话，
                // 有两种选择 1、把当前物品放入背包  2、不把当前物品放入背包，
                // 这两种选择取决于 放入当前物品后是否会导致背包容量溢出，
                // 如果溢出的话，就比较当前背包的价值与溢出的物品的价值大小
                // 如果溢出前物品的价值大，就不放入当前物品。
                // 如果溢出前的物品价值小，就放入当前物品，把之前放入的物品取出。
                // 如果不溢出的话，把当前物品也加入到背包中，之前的物品也不需要取出。
                 else if (j >= w[i-1]){//本来应该是j >= w[i] 的，但是我们的程序是从1开始的，所以要减1

                     // v[i][j] = Math.max(v[i-1][j],val[i-1] + v[i-1][j-w[i-1]]);
                     if (v[i-1][j] > val[i-1] + v[i-1][j-w[i-1]] ){
                         v[i][j] = v[i-1][j];

                     }else {
                         v[i][j] =  val[i-1] + v[i-1][j-w[i-1]];
                         path[i][j] = 1;
                     }


                 }
            }
        }


        //遍历二维数组，输出元素
        System.out.println("背包中物品的价值变化");
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[i].length; j++) {
                System.out.print(v[i][j] +"\t");
            }
            System.out.println();
        }

        System.out.println("================");
        int i = path.length - 1; //行的最大下标
        int j = path[0].length - 1;  //列的最大下标
        //从path的最后面开始找，看看到底背包中最后放置了哪几个物品
        while ( i > 0 && j > 0){
            if (path[i][j] == 1){
                System.out.println("第 " + i +" 个物品放入到背包中");
                j -= w[i-1];
            }
            i--;
        }
        System.out.println("背包中物品的最大价值是：" +v[n][m]);
    }
}

```



本次0-1背包算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=159&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 156 - 159p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

## 第3章 KMP算法

### 3.1 字符串匹配

![image-20220912165727534](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912165727534.png)

**暴力匹配的算法**

假设现在str1匹配到i位置，子串str2匹配到j位置，则

1）如果当前字符匹配成功（str1[i] == str2[j] ），则i++，j++，继续匹配下一个字符

2）如果匹配失败（str1[i] != str2[j] ） ，令i = i - （ j-1 ），j = 0；相当于每次匹配失败时，i回溯，j 被置为0

3）用暴力方法解决的话会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费大量的实践



**代码实现**

```java
package com.ldm.kmp;

/**
 * @author 梁东明
 * 2022/9/12
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 *
 * 字符串匹配
 */
public class ViolenceMath {
    public static void main(String[] args) {

        String str1 = " ldm mdl nomLn dnh";
        String str2 = "nh";
        int i = violenceMath(str1, str2);
        if ( i == -1){
            System.out.println("str1中没有str2");
        }else {
            System.out.println("str2在str1出现的索引位置在：" + i);
        }


    }
    //暴力匹配算法实现
    public static int violenceMath(String str1, String str2){
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int s1Len = s1.length;
        int s2Len  = s2.length;

        int i = 0; //字符串s1的初始索引
        int j = 0; //字符串s2的初始索引

        //
        while ( i < s1Len && j < s2Len){
          if ( s1[i] == s2[j]){//当出现第一个字符相等，继续比较
              i++;
              j++;
          }else {
              //不相等的话，i 后退 j-1 步
              //j 回到 第一步  即置为0
              i = i - (j-1);
              j = 0;
          }
        }

        //当退出循环，表示已经把两组字符串遍历完成了
        //接下就要看一看是否出现字符匹配的现象了
        if ( j == s2Len){  //如果str1中有str2的话，那么str2 应该遍历到尾部
            return i - j;  //那么就把str2在str1出现的索引返回
        }else {
            return -1;
        }

    }

}

```



### 3.2 基本介绍

1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现大的位置的经典算法

2）Knuth-Morris_Pratt字符串查找算法，简称：KMP算法，常用于在一个文本串内查找一个模式串P的出现位置，这个算法是由DonaldKnuth、vaughanPratt、JamesH.Morris三人于1977年联合发表，故取这三人的姓氏命名此算法

3）KMP方法算法就利用之前判断过信息，通过一个next数组，保存模串中前后最长公共子序列的长度，每次回溯时，就通过next数组找到，前面匹配过的位置，省去了大量的计算时间



<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912173537294.png" alt="image-20220912173537294" style="zoom:80%;" />

- 

<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912173735613.png" alt="image-20220912173735613" style="zoom:80%;" />

- 

<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912173758100.png" alt="image-20220912173758100" style="zoom:80%;" />





- 

**ABCDA 因为头尾都是A，所以是1，ABCDAB，因为头尾都是AB，所以是2**

移动位数 = 已匹配的字符数	- 对应的部分匹配值

<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912174106308.png" alt="image-20220912174106308" style="zoom:80%;" />

- 

![image-20220912174603089](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912174603089.png)

- 

![image-20220912174846089](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912174846089.png)

- 

<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912174920813.png" alt="image-20220912174920813" style="zoom:80%;" />

- 

![image-20220912175757381](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220912175757381.png)

**KMP**

1、先得到子串的部分匹配表

2、使用部分匹配表完成KMP匹配







这里ABCDABD，当匹配上ABCDAB的时候，我们想让他跳过中间没用的部分，直接到第二个AB处

而对于ABCDAB这个字符串，因为前缀AB和后缀AB是一样的，我们就可以把第二个AB当作新的起点

而对于ABCDAB这个字符串，因为前缀AB和后缀AB是一样的，我们就可以把第二个AB当作新的起点

我们就可以把第二个（也就是那个后缀）当作新的起点，而这里当然是要用这个后缀的第一个字符

而想达到这个字符的位置，我们需要前进的步数恰巧就是（已匹配字符的总长度 - 后缀的长度）

也就是从前缀的第一个字母到后缀的第一个字母要前进几步





**代码实现**



**获取一个字符串的（子串）的部分匹配值表**



```java
  //获取一个字符串的（子串）的部分匹配值表
    public static int[] kmpNext(String dest){
        //创建一个next数组保存部分匹配值
        int[] next = new int[dest.length()];

        for (int i = 1,j =0; i < dest.length(); i++) {
            //当dest.charAt(i) !=  dest.charAt(j)满足时，我们需要从next[j-1]获取j
            //直到我们发现dest.charAt(i) == dest.charAt(j)满足时，才退出
            //这时kmp算法的核心！！！！！！
            while( j > 0 && dest.charAt(i) !=  dest.charAt(j)){
                j = next[j-1];
            }

            //当dest.charAt(i) == dest.charAt(j)满足时，部分匹配值就+1
            if ( dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
```

**有注解的完整代码**



```java
package com.ldm.kmp;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/12
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 *
 * kmp算法
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] next = kmpNext(str2);  //求str2的部分匹配值表
        System.out.println(Arrays.toString(next));
        int i = kmpSearch(str1, str2, next);
        if ( i == -1){
            System.out.println("str1字符串没有包含str2");
        }else {
            System.out.println("str2在str1出现的索引位置在：" + i);
        }
    }

    /**
     * 写出kmp搜索算法
     *
     * @param str1 str1
     * @param str2 str2
     * @param next str2的部分匹配值表
     * @return int  str2如果存在str1，就返回其在str1出现的索引，没有就返回-1
     */
    public static int kmpSearch(String str1, String str2, int[] next){

        for (int i = 1,j =0; i < str1.length(); i++) {
            //当dest.charAt(i) !=  dest.charAt(j) 时，我们需要从next[j-1]获取j
            //直到我们发现dest.charAt(i) == dest.charAt(j)满足时，才退出
            //这时kmp算法的核心！！！！！！
            while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }

            //当dest.charAt(i) == dest.charAt(j)满足时，部分匹配值就+1
            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }
            if ( j == str2.length()){
                return i - j + 1;
            }
        }
        return -1;
    }

    //获取一个字符串的（子串）的部分匹配值表
    public static int[] kmpNext(String dest){
        //创建一个next数组保存部分匹配值
        int[] next = new int[dest.length()];

        for (int i = 1,j =0; i < dest.length(); i++) {
            //当dest.charAt(i) !=  dest.charAt(j)满足时，我们需要从next[j-1]获取j
            //直到我们发现dest.charAt(i) == dest.charAt(j)满足时，才退出
            //这时kmp算法的核心！！！！！！
            while( j > 0 && dest.charAt(i) !=  dest.charAt(j)){
                j = next[j-1];
            }

            //当dest.charAt(i) == dest.charAt(j)满足时，部分匹配值就+1
            if ( dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}

```

**无注解的完整代码**



有注解和无注解的代码的区别是：

有注解的代码是我理解老师代码后额外添加自己的注解

无注解的代码是我凭借对kmp算法的了解，自己手敲出来的，

所以一个注解都没有，放心食用。

```java
package com.ldm.kmp;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/12
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class MyKMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "caudicgbahvbajkccb";
        String str2 = "cb";
        int[] next = kmpNext(str2);
        System.out.println("部分匹配表 = " + Arrays.toString(next));

        int i = kmpAlgorithm(str1, str2, next);
        if ( i == -1){
            System.out.println("str1没有包含str2");
        }else {
            System.out.println("str2在str1出现的索引是 = " + i);
        }
    }

    public static int kmpAlgorithm(String str1,String str2, int[] next){
        for (int i = 0 ,j =0; i < str1.length(); i++) {
            while ( j > 0 && str1.charAt(i) != str2.charAt(j)){
                j = next[j-1];
            }
            if (str1.charAt(i) == str2.charAt(j)){
                j++;
            }
            if ( j == str2.length()){
                return i - j + 1;
            }
        }
        return -1;
    }

    public static int[] kmpNext(String dest){
        int[] next = new int[dest.length()];
        for (int i = 1, j= 0; i < dest.length(); i++) {
            while (j > 0 && dest.charAt(i) != dest.charAt(j)){
                j = next[j-1];
            }
            if (dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}

```



本次KMP算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=162&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 160-163p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第4章 贪心算法

### 4.1 应用场景

![image-20220913001137464](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913001137464.png)

可以使用排列组合的方法，假设有n个电台，那么，它们的组合是2^n -1次，找到可以满足所有地区都可以覆盖的电台集合。我们可以使用贪心算法。



### 4.2 贪心算法简介

1）贪心算法：是指在对问题进行求解时，在每一步选择中都采取最好或者最优的选择，从而希望能够导致结果是最好或者最优的算法

2）贪心算法所得的结果不一定是最优的结果（有时候会是最优解），但是都是相对近似（接近）最优解的结果



### 4.3 场景代码实现



找出满足所有地区都可以覆盖的电台集合

**实现思路：**

1）遍历所有的电台，找到一个覆盖了最多**未覆盖的地区**的电台（此电台可能包含一些已覆盖的电台）

2）将这个电台加入一个集合中（例如ArrayList），想办法把该电台覆盖的地区在下次比较时去掉

3）重复第一步直到覆盖了全部地区



**代码实现**

```java
package com.ldm.greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

/**
 * @author 梁东明
 * 2022/9/13
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 *
 * 贪心算法
 */
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台,放入到Map
        HashMap<String,HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
        //将各个电台放入到broadcasts
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);

        //allAreas 存放所有的地区
        HashSet<String> allAreas = new HashSet<String>();
           allAreas.addAll(hashSet1);
           allAreas.addAll(hashSet2);
           allAreas.addAll(hashSet3);
           allAreas.addAll(hashSet4);
           allAreas.addAll(hashSet5);

        System.out.println("需要广播的地区分别为："+allAreas);
        System.out.println("电台分别为："+broadcasts);

        //创建ArrayList，存放选择的电台集合
        ArrayList<String> selects = new ArrayList<>();

        //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<String>();

        //定义maxKey，保存在一次遍历过程中，能够覆盖的最大未覆盖的地区的对应电台的key
        //如果maxKey不为null，则会放入到selects中
        String maxKey = null;
        while ( allAreas.size() != 0){//如果地区没被覆盖完，就不许退出循环

            //每进行一次while,需要
            maxKey = null;
            //遍历电台broadcasts集合,取出每个电台的广播范围的key值
            for (String key : broadcasts.keySet()) {
                //每进行一次for
                tempSet.clear();
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //求出tempSet与allAreas的集合 的交集,然后赋给temSet
                tempSet.retainAll(allAreas);
                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多
                //就需要重置maxKey

                //这三行代码才是贪心算法的核心
                if (tempSet.size() > 0 &&
                    (maxKey == null || tempSet.size() > broadcasts.get(maxKey).size())){
                    maxKey = key;
                }
            }
            //maxKey != null，就需要把maxKey放入selects
            if ( maxKey  != null){
                selects.add(maxKey);
                //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }

        }
        System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]

    }
}

```





本次贪心算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=168&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 164-168p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第5章 普利姆算法

### 5.1 应用场景

![image-20220913161249435](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913161249435.png)



**思路：**

尽可能的选择小的路线，并且每条路线最小，保证总里程数最小



**所以，我们必须先了解什么是最小生成树**



### 5.2 最小生成树

**基本介绍：**

1）给定一个带权的无向连通图，如何选取一颗生成树，使得树上所有边上权的总和为最小，这个叫最小生成树

2）N个顶点，一定有N - 1 条边

3）包含全部顶点

4）N - 1 条边都在图中

5）求最小生成树的算法主要是普利姆算法和克鲁斯卡尔算法

![image-20220913162033369](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913162033369.png)

### 5.3 普利姆算法简介



1）普利姆（Prim）算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有（n - 1 ）条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图

2）普利姆算法如下

- ①设G = (V,E) 是连通图，T = (U,D) 是最小生成树， V、U是顶点集合，E，D是边的集合
- ②若从顶点u开始构成最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v 的visited[u] = 1
- ③若集合U中顶点  u i 与集合 V-U的顶点 v j 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 v j 加入到集合U中，将边（u i，v j）加入集合中，标记visited [v j] = 1 
- ④重复步骤②，直到U和V相等，即所有顶点都被标记为访问过，此时D中有n - 1 条边

**图解：**

![image-20220913164449473](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913164449473.png)



### 5.4 代码实现

```java
package com.ldm.prim;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/13
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class PrimAlgorithm {
    public static void main(String[] args) {
        //测试看看图是否创建ok
        char[] data = {'A','B','C','D','E','F','G'};
        int verxs = data.length;  //顶点的个数就是data的长度
        //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通
        int [][]weight={
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000},};

        //创建Graph对象
        Graph graph = new Graph(verxs);
        //创建一个MinTree对象
        Tree tree = new Tree();
        tree.createGraph(graph, verxs, data, weight);

        Tree.prim(graph,0);

    }


}

//创建树
class Tree{
    /**
     * 创建图的邻接矩阵
     *
     * @param graph    图
     * @param vertexes 顶点
     * @param data     图各个顶点的值
     * @param weight   图的邻接矩阵
     */
    public void createGraph(Graph graph,int vertexes,char[] data, int[][] weight){

        for (int i = 0; i < vertexes; i++) { //顶点
            graph.data[i] = data[i]; //把传进来的顶点的值赋值给图
            for (int j = 0; j < vertexes; j++) {
                graph.weight[i][j] = weight[i][j]; //把传进来的邻接矩阵赋给图
            }
        }
    }
    //显示图的邻接矩阵
    public void showGraph(Graph graph){
        //把二维数组（邻接矩阵）的每一行输出来
        //这是增强for循环，跟普通的for循环没啥两样，就是代码简介一点而已
        for (int[]  link : graph.weight) {
            System.out.println(Arrays.toString(link));
        }

    }
    /**
     * 普利姆算法
     * 把图 转成 最小生成树
     *
     * @param graph 图
     * @param v   表示图从哪一个结点开始生成最小生成树
     */
    public static void prim(Graph graph, int v){

        int totalWeight = 0;  //记录最小生成树的总最小权值
        //创建一个数组，用来表示顶点是否被访问过，
        //1 表示已访问过  0 表示没有被访问过
        int[] isVisited = new int[graph.vertexes];
        //把传进来的第一个顶点设置为已访问
        isVisited[v] = 1;

        //设置两个临时变量来保存接下来循环中用到的两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        //将最小值设置为10000，表示两个顶点之间没有边，二者不可达
        int minWeight = 10000;

        //最小生成树的一个很关键的特点
        //n个顶点的图会生成n-1 条边的最小生成树 ，所以遍历图的顶点的时候要从1开始
        for (int k = 1; k < graph.vertexes; k++) {

            //对已访问的顶点和未被访问的顶点开始for循环遍历
            for (int i = 0; i < graph.vertexes; i++) {//设i为已访问过的顶点
                for (int j = 0; j < graph.vertexes; j++) {//设j为未被访问过的顶点
                    //graph.weight[i][j] < minWeight 两个顶点之间的边
                    //只要两个顶点只要有边，其值graph.weight[i][j]肯定小于minWeight
                    //因为初始化的minWeight为10000，超级无敌大
                    if (isVisited[i] == 1 && isVisited[j] ==0
                            && graph.weight[i][j] < minWeight){
                        //for循环刚开始 二者有边，它们的值就先保存下来
                        minWeight = graph.weight[i][j];

                        //保存二者的下标
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            totalWeight += minWeight; //每退出前面两个for循环就把minWeight保存
            System.out.println("边< " + graph.data[h1] +","+graph.data[h2] +" > 权值为： " +minWeight);
            //退出前面两个for循环之后，找到已被访问顶点和其周边未被访问的顶点的 最小权值的边
            //把未被访问的顶点设置为已被访问
            isVisited[h2] = 1;
            //将最小值设重新置为10000，方便第一个for循环重新构成最小生成树
            minWeight = 10000;
        }
        System.out.println("该最小生成树的路径为 "+totalWeight);
    }

}

class Graph{
    int vertexes;   //存放边
    char[] data;    //存放结点数据
    int[][] weight; //存放边，就是邻接矩阵

    public Graph(int vertexes) {
        this.vertexes = vertexes;
        data = new char[vertexes];
        weight = new int[vertexes][vertexes];
    }


}

```



本次普利姆算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=171&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 168-171p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

## 第6章 克鲁斯卡尔算法

### 6.1 应用场景

![image-20220913231337462](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913231337462.png)

### 6.2 算法介绍

1）克鲁斯卡尔（kruskal）算法，是用来求加权连通图的最小生成树的算法

2）基本思想：按照权值从小到大的顺序选择n-1条边（假设最小生成树有n个顶点，则有n-1条边），并保证这n-1条边不构成回路

3）具体做法：首先构造一个只含n个顶点的森林，然后依照权值从小到大从连通网中选取边加入到森林中，使得森林中不产生回路，直到森林变成一颗树为止（最小生成树）



### 6.3 图解算法

![image-20220913232942790](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220913232942790.png)

-- 
![在这里插入图片描述](https://img-blog.csdnimg.cn/96c65deb81fc42f7a6c0f3428d075367.png)

- 
![在这里插入图片描述](https://img-blog.csdnimg.cn/7b1b8d19487d4491ae7eec48f85f65a4.png)

- 
![在这里插入图片描述](https://img-blog.csdnimg.cn/92fad1bb0a06488ea05e802ded45ccbb.png)


-
注意第四步虽然<C,F>是剩下未被选取的边中权值最小的，但是不选取<C,F>边是因为会导致回路
![在这里插入图片描述](https://img-blog.csdnimg.cn/c6f835b7b7f54ab2bcddcf2579c91bc7.png)步骤
![在这里插入图片描述](https://img-blog.csdnimg.cn/d31911c4d8754f7a96cc53019f58c24f.png)**克鲁斯卡尔算法分析**
![在这里插入图片描述](https://img-blog.csdnimg.cn/b33abba091a04603ad7cfecd8251a7c1.png)


**如何判断是否构成回路--举例说明**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2d1a5d2259584c0f83652facf99bfdd8.png)

- 
![在这里插入图片描述](https://img-blog.csdnimg.cn/5d655f35310e41c582175d37d877865d.png)

### 6.3 代码实现

```
实现步骤：
1、先创建图
2、创建图的边类，用来保存图的边
3、对图的边按照权值大小进行排序
4、进行克鲁斯卡尔算法
   1）取出边集中最小的边的两个顶点创建最小生成树
   2）判断这两个顶点在生成树期间是否造成回路
   3）循环1）和2）直到所有的顶点都放入最小生成树中
5、生成最小生成树
```



```java
package com.ldm.kruskal;

import java.util.Arrays;

public class KruskalCase {

	private int edgeNum; //边的个数
	private char[] vertexs; //顶点数组
	private int[][] matrix; //邻接矩阵
	//使用 INF 表示两个顶点不能连通
	private static final int INF = Integer.MAX_VALUE;

	public static void main(String[] args) {
		//创建顶点数组
		char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
		//图的邻接矩阵（二维数组）
		int matrix[][] = {
				        /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
				/*A*/ {   0,  12, INF, INF, INF,  16,  14},
				/*B*/ {  12,   0,  10, INF, INF,   7, INF},
				/*C*/ { INF,  10,   0,   3,   5,   6, INF},
				/*D*/ { INF, INF,   3,   0,   4, INF, INF},
				/*E*/ { INF, INF,   5,   4,   0,   2,   8},
				/*F*/ {  16,   7,   6, INF,   2,   0,   9},
				/*G*/ {  14, INF, INF, INF,   8,   9,   0}};
		//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.

		//创建KruskalCase 对象实例
		KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
		
		kruskalCase.kruskal();
	}

	//构造器
	public KruskalCase(char[] vertexs, int[][] matrix) {
		//初始化顶点数和边的个数
		int vlen = vertexs.length;

		//初始化顶点, 复制拷贝的方式
		this.vertexs = new char[vlen];
		for(int i = 0; i < vertexs.length; i++) {
			this.vertexs[i] = vertexs[i];
		}

		//初始化边, 使用的是复制拷贝的方式
		this.matrix = new int[vlen][vlen];
		for(int i = 0; i < vlen; i++) {
			for(int j= 0; j < vlen; j++) {
				this.matrix[i][j] = matrix[i][j];
			}
		}
		//统计边的条数
		for(int i =0; i < vlen; i++) {
			for(int j = i+1; j < vlen; j++) {
				if(this.matrix[i][j] != INF) {
					edgeNum++;
				}
			}
		}

	}
	public void kruskal() {
		int index = 0; //表示最后结果数组的索引
		//用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点
		//用来判断是否出现回路
		int[] ends = new int[edgeNum];
		//创建结果数组, 保存最后的最小生成树
		EData[] rets = new EData[edgeNum];
		//统计最小生成树的总权值
		int totalWeight = 0;

		//获取图中 所有的边的集合 ， 一共有12边
		EData[] edges = getEdges();
		System.out.println("图的边的集合=" + Arrays.toString(edges) + " 共"+ edges.length); //12

		//按照边的权值大小进行排序(从小到大)
		sortEdges(edges);

		//遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入
		for(int i=0; i < edgeNum; i++) {
			//获取到第i条边的第一个顶点(起点)
			int p1 = getPosition(edges[i].start);
			//获取到第i条边的第2个顶点
			int p2 = getPosition(edges[i].end);

			//获取p1这个顶点在已有最小生成树中的终点
			int m = getEnd(ends, p1);
			//获取p2这个顶点在已有最小生成树中的终点
			int n = getEnd(ends, p2);
			//是否构成回路
			if(m != n) { //没有构成回路
				ends[m] = n; // 设置m 在"已有最小生成树"中的终点
				rets[index++] = edges[i]; //有一条边加入到rets数组
			}
		}
		//<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
		//统计并打印 "最小生成树", 输出  rets
		System.out.println("最小生成树为");
		for(int i = 0; i < index; i++) {
			System.out.println(rets[i]);
			totalWeight += rets[i].weight;
		}
		System.out.println("最小生成树的权值为：" + totalWeight);
	}
	/**
	 * 功能：对边进行排序处理, 冒泡排序
	 * @param edges 边的集合
	 */
	private void sortEdges(EData[] edges) {
		for(int i = 0; i < edges.length - 1; i++) {
			for(int j = 0; j < edges.length - 1 - i; j++) {
				if(edges[j].weight > edges[j+1].weight) {//交换
					EData tmp = edges[j];
					edges[j] = edges[j+1];
					edges[j+1] = tmp;
				}
			}
		}
	}
	/**
	 *
	 * @param ch 顶点的值，比如'A','B'
	 * @return 返回ch顶点对应的下标，如果找不到，返回-1
	 */
	private int getPosition(char ch) {
		for(int i = 0; i < vertexs.length; i++) {
			if(vertexs[i] == ch) {//找到
				return i;
			}
		}
		//找不到,返回-1
		return -1;
	}
	/**
	 * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组
	 * 是通过matrix 邻接矩阵来获取
	 * EData[] 形式 [['A','B', 12], ['B','F',7], .....]
	 * @return
	 */
	private EData[] getEdges() {
		int index = 0;
		EData[] edges = new EData[edgeNum];
		for(int i = 0; i < vertexs.length; i++) {
			for(int j=i+1; j <vertexs.length; j++) {
				if(matrix[i][j] != INF) {
					edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
				}
			}
		}
		return edges;
	}
	/**
	 * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同
	 * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成
	 * @param i : 表示传入的顶点对应的下标
	 * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解
	 */
	private int getEnd(int[] ends, int i) { // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]
		while(ends[i] != 0) {
			i = ends[i];
		}
		return i;
	}

}

//创建一个类EData ，它的对象实例就表示一条边
class EData {
	char start; //边的一个点
	char end; //边的另外一个点
	int weight; //边的权值
	//构造器
	public EData(char start, char end, int weight) {
		this.start = start;
		this.end = end;
		this.weight = weight;
	}
	//重写toString, 便于输出边信息
	@Override
	public String toString() {
		return "边 <" + start + ", " + end + "> 权值为= " + weight + "";
	}


}

```



本次克鲁斯卡尔算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=172&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 172-177p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。



## 第7章 迪杰斯特拉算法

### 7.1应用场景

**最短路径为题**



![image-20220914112400515](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220914112400515.png)

### 7.2 算法介绍

迪杰斯特拉（Dijkstra）算法是典型最短路径算法，用于计算一个顶点到其他顶点的最短路径。它的主要特点是以起始点为中心向外层层扩展（广度优先搜索思想），直到扩展到终点为止。

**算法过程**

设置出发顶点为v，顶点集合V{ v1， v2,vi ....} ，v到V中各顶点的距离构成距离集合Dis，Dis{ d1，d2，di...}，Dis集合记录着b到图中各顶点的距离(到自身距离为0，v 到vi距离对应为di)

1）**从Dis中选择值最小的di移出Dis集合**，同时移出V集合中对应的顶点vi，此时的v到vi即是最短路径

2）更新Dis集合，更新规则为：**比较v到V集合中顶点的距离值**，与v通过vi到V集合中顶点的距离值，**保留值较小的一个**（同时也因该更新顶点的前驱顶点为vi，表明是通过vi到达的）

3重复执行上面两步骤，直到最短路径顶点为目标顶点即可结束。



### 7.3 算法图解

![image-20220914152107284](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220914152107284.png)

-

![image-20220914153309741](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220914153309741.png)

-

### 7.4 代码实现

```
实现步骤：
1、创建图类（显示图 邻接矩阵）
2、定义顶点数组  和 邻接矩阵 
   定义final  N = 65535表示两顶点不可达
   邻接矩阵赋值
3、创建图对象  测试输出图的邻接矩阵
4、记录已访问结点集合 创建一个类
   创建三个数组already_arr[] pre_visited[] dis[]
   1）记录各个是否已经全部访问的数组
   2)记录每个顶点被访问前的前驱顶点
   3）保存出发顶点与其他相怜顶点的边的距离，无边的话就是N
   创建构造器（int lenth ，int index）
   1）lenth：表示顶点的个数
   2）index：出发顶点对应的下标
   3）初始化dis[] Arrays.fi ll(dis,65535)
   4)this.dis[index] = 0;
   判断index顶点是否被访问过boolean类型方法
   更新dis[] 更新出发顶点到index顶点的距离(int len,int index)
   更新pre[] 更新pre这个顶点的前驱顶点为index顶点（int pre，int    index）
   返回出发顶点到index顶点的距离
5、迪杰斯特拉算法实现
   创建VisitedVertex对象
   
6、更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点
   根据遍历邻接矩阵的 行  
   1）更新j顶点的前驱为index顶点
   2）更新出发顶点到j顶点的距离
7、在4中类添加方法
   继续选择并返回新的访问顶点（注意：不是出发顶点了）	
8、在dis算法中更新index顶点到周围顶点的的距离和前驱

      
```



```java
package com.ldm.dijkstra;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/14
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class DijkstraAlgorithm {
    static char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
    public static void main(String[] args) {

        //邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;// 表示不可以连接
        matrix[0]=new int[]{N, 5, 7, N, N, N, 2};
        matrix[1]=new int[]{5,N,N,9,N,N,3};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,3,N,N,4,6,N};
        //创建 Graph对象
        Graph graph = new Graph(vertex, matrix);
        //出发顶点对应的下标
        graph.dsj(6);
        //出发顶点对应的下标
        graph.showDijkstra(6);
    }
}



class Graph{
    private char[] vertex;  //顶点数组
    private int[][] matrix; //邻接矩阵
    private VisitedVertex vv; //已经访问的顶点的集合

    public Graph(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }
    //显示图
    public void showGraph(){
        for (int[] links : matrix) {
            System.out.println(Arrays.toString(links));
        }
    }
    //显示Dijkstra算法的结果
    public void showDijkstra(int index){
        vv.show(index);
    }

    /**
     * 迪杰斯特拉算法实现
     *
     * @param index 出发顶点的下标
     */
    public void dsj(int index){
        vv = new VisitedVertex(vertex.length,index);
        update(index); //更新index下标的顶点到周围顶点的距离和前驱顶点
        //这里使用到贪心算法动态规划的思想
        for (int j = 0; j < vertex.length; j++) {
            index = vv.updateArr();//选择并返回新的访问结点
            update(index); //更新index下标的顶点到周围顶点的距离和前驱顶点
        }


    }

    /**
     * 更新index下标顶点的周围顶点的距离和周围顶点的前驱顶点，需要遍历图
     *
     * @param index index下标顶点
     */
    private void update(int index){

        int len; //index下标顶点的周围顶点的距离
        //根据遍历邻接矩阵的 matrix[index]行 用到图的广度遍历
        for (int j = 0; j < matrix[index].length; j++) {
            // len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和
            len = vv.getDis(index) + matrix[index][j];

            // 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新
            if (!vv.in(j) && len < vv.getDis(j)){
                vv.updatePre(j,index);  //更新j这个顶点的前驱顶点为index
                vv.updateDis(j,len);    //更新j这个顶点到出发顶点的距离
            }
        }
        //for循环结束之后，记得要自己debug哦，不然单看代码不跟着流程走，你绝对会很懵逼
        //isVisited = {0,0,0,0,0,0,0}
        //pre_visited = {6,6,0,0,6,6,0}
        //dis = { 2,3,65535,65535,4,6,0}

    }

}

// 已访问顶点集合
class VisitedVertex {
    //记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新
    public int[] isVisited;
    //保存当前顶点的前继顶点
    public int[] pre_visited;
    //记录出发顶点到其他所有顶点的距离,
    //比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis
    public int[] dis;

    char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };

    /**构造器
     * 参观了顶点
     *
     * @param length 顶点的个数
     * @param index  出发点的下标
     */
    public VisitedVertex(int length, int index) {
        this.isVisited = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];
        //初始化dis数组
        Arrays.fill(dis,65535);
        //设置出发点被访问过
        this.isVisited[index] = 1;
        //出发顶点的访问距离是0
        this.dis[index] = 0;
    }

    /**
     * 判断index是否被访问过
     * @param index 下标
     * @return 如果访问过就返回ture，否则返回false
     */
    public boolean in(int index){
        return isVisited[index] == 1;
    }

    /**
     * 更新出发顶点到index顶点的距离
     *
     * @param len 传入的距离
     */
    public void updateDis(int index,int len){
        dis[index] = len;
    }

    /**
     * 更新 index顶点的前驱为顶点为pre顶点
     *
     * @param index 传入的顶点index
     * @param pre 传入的顶点pre
     */
    public void updatePre(int index,int pre){
        pre_visited[index] = pre;
    }

    /**
     * 返回出发点到index的顶点的距离
     *
     * @param index 指数
     */
    public int getDis(int index){
        //在第123行的方法中赋值
        return dis[index];
    }

    /**
     * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点)
     *
     * @return int
     */
    public int updateArr(){
        int min = 65535, index = 0;
        //如果所有顶点没有被全部访问，for循环就不会退出
        for (int i = 0; i < isVisited.length; i++) {
            //当前顶点没有被访问,并且距离 小于min
            if ( isVisited[i] == 0 && dis[i] < min){
                //更新min的值
                min = dis[i];
                index = i ;
            }
        }
        //更新index为已访问过
        isVisited[index] = 1;
        return index;
    }
    //显示最后的结果
    //即将三个数组的情况输出
    public void show(int index) {

        System.out.println("==========================");
        //输出isVisited
        System.out.println("所有顶点是否全部被访问？");
        boolean[] Visited = new boolean[isVisited.length];

        for (int i = 0; i < isVisited.length; i++) {
            if ( isVisited[i] == 1){
                Visited[i] = true;
            }
        }
        for (boolean b : Visited) {
            System.out.print(b+" ");
        }
        System.out.println();
        System.out.println("\nA B C D E F G \n对应的前驱结点为：");
        //输出pre_visited
        for (int i : pre_visited) {
            System.out.print(vertex[i] + " ");
        }

        System.out.println("\n它们的边的权值分别为");
        //输出dis
        //统计最短路径
        int totalWeight = 0;
        for(int i : dis) {
            System.out.print(i + " ");
            totalWeight += i;
        }
        System.out.println();
        //为了好看最后的最短距离，我们处理
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        int count = 0;
        for (int i : dis) {
            if (i != 65535) {
                System.out.print(vertex[count] + "("+i+") ");
            } else {
                System.out.println("N ");
            }
            count++;
        }
        System.out.println();
        System.out.println(vertex[index]+"到其他顶点的最短路径为：" + totalWeight);

    }
}
/*
实现步骤：
1、创建图类（显示图 邻接矩阵）
2、定义顶点数组  和 邻接矩阵
   定义final  N = 65535表示两顶点不可达
   邻接矩阵赋值
3、创建图对象  测试输出图的邻接矩阵
4、记录已访问结点集合 创建一个类
   创建三个数组already_arr[] pre_visited[] dis[]
   1）记录各个是否已经全部访问的数组
   2)记录每个顶点被访问前的前驱顶点
   3）保存出发顶点与其他相怜顶点的边的距离，无边的话就是N
   创建构造器（int lenth ，int index）
   1）lenth：表示顶点的个数
   2）index：出发顶点对应的下标
   3）初始化dis[] Arrays.fi ll(dis,65535)
   4)this.dis[index] = 0;
   判断index顶点是否被访问过boolean类型方法
   更新dis[] 更新出发顶点到index顶点的距离(int len,int index)
   更新pre[] 更新pre这个顶点的前驱顶点为index顶点（int pre，int    index）
   返回出发顶点到index顶点的距离
5、迪杰斯特拉算法实现
   创建VisitedVertex对象

6、更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点
   根据遍历邻接矩阵的 行
   1）更新j顶点的前驱为index顶点
   2）更新出发顶点到j顶点的距离
7、在4中类添加方法
   继续选择并返回新的访问顶点（注意：不是出发顶点了）
8、在dis算法中更新index顶点到周围顶点的的距离和前驱


 */

```



本次迪杰斯特拉算法算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=178&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 178-184p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇。

## 第8章弗洛伊德算法

### 8.1算法介绍

**弗洛伊德(Floyd)算法**

1）和Dijkstra算法一样，弗洛伊德（Floyd）算法也是一种用于寻找给定的加权图中顶点间最短路径的算法，该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特-弗洛伊德命名

2）弗洛伊德（Floyd）算法计算图中各顶点之间的最短路径

3）迪杰斯特拉算法用于计算图中某一顶点到其他顶点的最短路径

4）**弗洛伊德算法与迪杰斯特拉算法的区别**：迪杰斯特拉算法通过选定的被访问顶点，求出发访问顶点到其他顶点的最短路径，而弗洛伊德算法中每一个顶点都是出发访问顶点，所以需要将每一个顶点看作被访问顶点，求出从每一个顶点到其他顶点的最短路径

### 8.2 算法图解

1）设置顶点vi到顶点vk的**最短**路径已知为Lik，顶点vk到vj的**最短**路径已知为Lkj，顶点vi到vj的路径为Lij，则vi带vj的**最短**路径为：min{ Lij, Lik+Lkj},vk的取值为图中所有顶点，则可以获取到vi到vj的最短路径

2）至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得

3）图解	

![image-20220915121704298](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220915121704298.png)



- 


![在这里插入图片描述](https://img-blog.csdnimg.cn/4d8c90a47911478a9fa3c3cfb34f8bf0.png)

- 
**弗洛伊德算法的步骤**
	第一轮循环中，以A（下标为0作为中间顶点【即把A作为中间顶点的全部情况都进行遍历 ，就会得到新的距离表和前驱关系】，![在这里插入图片描述](https://img-blog.csdnimg.cn/687fd18cb6fc4d3dbc941a16dfaa0f59.png)

-
找A相连的顶点，因为只有与A相连，A才能做中间顶点。明显与A相连的顶点有CBG
![image-20220915152812243](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220915152812243.png)



**三层for循环思想**
![在这里插入图片描述](https://img-blog.csdnimg.cn/68241fa4f8554af49768c4170d816486.png)





### 8.3 应用场景

![image-20220915153437219](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220915153437219.png)

### 8.4 代码实现

```
实现步骤：
1、创建图
  char[]存放顶点数组
  int[][] dis 从各个顶点出发到其他顶点的距离
  int[][] pre 保存到达目标顶点的前驱顶点
  
 构造器 (int length,int[][] matrix, char[] vertex)
 //对pre数组初始化，存放的是前驱顶点的下标   
 
 显示pre数组和dis数组
2、在图类中使用弗洛伊德算法
public void floyd(){
        int len = 0; //临时变量保存两点的最短距离
        //k 是中间顶点，对k遍历
        for (int k = 0; k < dis.length; k++) {
            //i是出发顶点，对i遍历
            for (int i = 0; i < dis.length; i++) {
                //j是目的顶点，对j遍历
                for (int j = 0; j < dis.length; j++) {
                    len = dis[i][k] + dis[k][j];// => 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离
                    //这里用到贪心算法的思想，谁最小选择谁做最小距离
                    if ( len < dis[i][j]){//如果len小于 dis[i][j]
                        dis[i][j] = len;  //更新距离
                        pre[i][j] = pre[k][j]; //更新前驱顶点
                    }
                }
            }
        }
    }
 
  
```



```java
package com.ldm.floyd;

import java.util.Arrays;

/**
 * @author 梁东明
 * 2022/9/15
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class FloydAlgorithm {
    public static void main(String[] args) {
        // 测试看看图是否创建成功
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        //创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
        matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
        matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
        matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
        matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
        matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
        matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };

        //创建 Graph 对象
        Graph graph = new Graph(vertex.length, matrix, vertex);
        graph.floyd();
        graph.show();
    }
}

class Graph{
    private char[] data; //存放顶点数组
    private int[][] dis;  //各个顶点到其他顶点的距离
    private int[][] pre;  //保存到达目的顶点的前驱顶点

    public Graph(int length, int[][] matrix, char[] vertex) {
        this.data = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];
        //对pre数组初始化，存放的是前驱顶点的下标
        for (int i = 0; i < length; i++) {
            Arrays.fill(pre[i] ,i);
        }
    }

    /**
     * 显示pre数组和dis数组
     */
    public void show(){
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        
        System.out.println("各个顶点到其他顶点的最短距离");
        for (int i = 0; i < dis.length; i++) {
            for (int j = 0; j < dis.length; j++) {
                System.out.print(dis[i][j] + "\t");
            }
            System.out.println();
        }
        System.out.println("各个顶点到达目的顶点的前驱顶点");
        for (int i = 0; i < pre.length; i++) {
            for (int j = 0; j < pre.length; j++) {
                System.out.print(vertex[pre[i][j]] + "\t");
            }
            System.out.println();
        }
    }

    /**
     * 弗洛伊德算法实现
     */
    public void floyd(){
        int len = 0; //临时变量保存两点的最短距离
        //k 是中间顶点，对k遍历
        for (int k = 0; k < dis.length; k++) {
            //i是出发顶点，对i遍历
            for (int i = 0; i < dis.length; i++) {
                //j是目的顶点，对j遍历
                for (int j = 0; j < dis.length; j++) {
                    len = dis[i][k] + dis[k][j];// => 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离
                    //这里用到贪心算法的思想，谁最小选择谁做最小距离
                    if ( len < dis[i][j]){//如果len小于 dis[i][j]
                        dis[i][j] = len;  //更新距离
                        pre[i][j] = pre[k][j]; //更新前驱顶点
                    }
                }
            }
        }
    }
}

```



本次弗洛伊德算法算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=188&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 185-188p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇



## 第9章 骑士周游问题

### 9.1 马踏棋盘游戏

1）马踏棋盘算法也被称为骑士周游问题

2）将马随机放在国际象棋的8*8棋盘上Board[0~7] [0~7]的某个方格中，马按照走棋规则（马走日字）进行移动。要求每个方格只进行一次，走遍棋盘上全部64各方格

### 9.2 骑士周游回溯算法实现

1）马踏棋盘（骑士周游问题）实际上是图的深度优先搜索（DFS）的应用

2）如果使用回溯（深度优先搜索）来解决，假如马走了53个点，如图：坐标（1，0）发现已经走到尽头，没有办法继续回退，查看其他路径，就在棋盘上不停的回溯，

3）分析第一种方式的问题，使用贪心算法（greedyAlgorithm）进行优化，解决马踏棋盘问题

![image-20220915221602991](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20220915221602991.png)





-
![在这里插入图片描述](https://img-blog.csdnimg.cn/8ba2dafe46a54eca9441f5783c5d8d44.png)后续会用贪心算法优化

### 9.3 代码实现
**没有使用贪心算法花费21秒走完**
![在这里插入图片描述](https://img-blog.csdnimg.cn/6878703ef1d348a4b859d9f1e4c91f23.png)

```java
package com.ldm.horse;

import java.awt.*;
import java.util.ArrayList;

/**
 * @author 梁东明
 * 2022/9/15
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HorseChessBoard {
    private static int X; //棋盘的列数
    private static int Y; //棋盘的行数
    //创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置都被访问
    private static boolean finished; // 如果为true,表示成功

    public static void main(String[] args) {
        System.out.println("骑士周游算法，开始运行~~");
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        int row = 1; //马儿初始位置的行，从1开始编号
        int column = 1; //马儿初始位置的列，从1开始编号
        //创建棋盘
        int[][] chessBoard = new int[X][Y];
        visited = new boolean[X*Y];
        //测试一下耗时
        long start = System.currentTimeMillis();
        traverSalChessBoard(chessBoard,row-1,column-1,1);
        long end = System.currentTimeMillis();
        System.out.println("总耗时="+(end-start)+" 毫秒");

        //输出棋盘的情况
        for (int[] rows : chessBoard) {
            for (int step : rows) {
                System.out.print(step +"\t");
            }
            System.out.println();
        }


    }

    /**
     * 骑士周游算法实现
     *
     * @param chess  棋盘
     * @param row    马当前的位置的行 从0开始
     * @param column 马当前的位置的列 从0开始
     * @param step   第几步，初始是第一步
     */
    public static void traverSalChessBoard(int[][] chess, int row, int column, int step){
        //把传入的第一个点蛇者为第一步
        chess[row][column] = step;
        visited[row*X+column] = true; //标记该位置已经访问
        //获取当前位置可以走下一个位置的集合
        ArrayList<Point> ps = next(new Point(row, column));
        //遍历ps
        while ( !ps.isEmpty()){
            Point remove = ps.remove(0); //取出下个可以走的位置
            //判断该点是否被访问过
            if (!visited[remove.x*X+remove.y]){
                //回溯（递归）
                traverSalChessBoard(chess, remove.x, remove.y, step+1);
            }
        }
        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，
        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0
        //说明: step < X * Y  成立的情况有两种
        //1. 棋盘到目前位置,仍然没有走完
        //2. 棋盘处于一个回溯过程
        if ( step < X*Y && !finished){
            chess[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }
    }
    /**
     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)
     * 并放入到一个集合中(ArrayList), 最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        //创建一个ArrayList
        ArrayList<Point> ps = new ArrayList<>();
        //创建一个Point
        Point p1 = new Point();
        //表示马儿可以走5这个位置
        if((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y -1) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走6这个位置
        if((p1.x = curPoint.x - 1) >=0 && (p1.y=curPoint.y-2)>=0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走7这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走0这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走1这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走2这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走3这个位置
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走4这个位置
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        return ps;
    }
}

```
**使用贪心算法优化 17毫秒走完**
![在这里插入图片描述](https://img-blog.csdnimg.cn/e341562137ac464c9d21d5c33f07cae0.png)

-
![在这里插入图片描述](https://img-blog.csdnimg.cn/b1d7970f3ff04671a7e52f261d948730.png)

```java
package com.ldm.horse;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * @author 梁东明
 * 2022/9/15
 * 人生建议：看不懂的方法或者类记得CTRL + 点击 看看源码或者注解
 * 点击setting在Editor 的File and Code Templates 修改
 */
public class HorseChessBoard {
    private static int X; //棋盘的列数
    private static int Y; //棋盘的行数
    //创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置都被访问
    private static boolean finished; // 如果为true,表示成功

    public static void main(String[] args) {
        System.out.println("骑士周游算法，开始运行~~");
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        int row = 1; //马儿初始位置的行，从1开始编号
        int column = 1; //马儿初始位置的列，从1开始编号
        //创建棋盘
        int[][] chessBoard = new int[X][Y];
        visited = new boolean[X*Y];
        //测试一下耗时
        long start = System.currentTimeMillis();
        traverSalChessBoard(chessBoard,row-1,column-1,1);
        long end = System.currentTimeMillis();
        System.out.println("总耗时="+(end-start)+" 毫秒");

        //输出棋盘的情况
        for (int[] rows : chessBoard) {
            for (int step : rows) {
                System.out.print(step +"\t");
            }
            System.out.println();
        }


    }

    /**
     * 骑士周游算法实现
     *
     * @param chess  棋盘
     * @param row    马当前的位置的行 从0开始
     * @param column 马当前的位置的列 从0开始
     * @param step   第几步，初始是第一步
     */
    public static void traverSalChessBoard(int[][] chess, int row, int column, int step){
        //把传入的第一个点蛇者为第一步
        chess[row][column] = step;
        visited[row*X+column] = true; //标记该位置已经访问
        //获取当前位置可以走下一个位置的集合
        ArrayList<Point> ps = next(new Point(row, column));

        //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序
        sort(ps);
        //遍历ps
        while ( !ps.isEmpty()){
            Point remove = ps.remove(0); //取出下个可以走的位置
            //判断该点是否被访问过
            if (!visited[remove.x*X+remove.y]){
                //回溯（递归）
                traverSalChessBoard(chess, remove.x, remove.y, step+1);
            }
        }
        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，
        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0
        //说明: step < X * Y  成立的情况有两种
        //1. 棋盘到目前位置,仍然没有走完
        //2. 棋盘处于一个回溯过程
        if ( step < X*Y && !finished){
            chess[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }
    }
    /**
     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)
     * 并放入到一个集合中(ArrayList), 最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        //创建一个ArrayList
        ArrayList<Point> ps = new ArrayList<>();
        //创建一个Point
        Point p1 = new Point();
        //表示马儿可以走5这个位置
        if((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y -1) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走6这个位置
        if((p1.x = curPoint.x - 1) >=0 && (p1.y=curPoint.y-2)>=0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走7这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走0这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走1这个位置
        if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走2这个位置
        if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走3这个位置
        if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走4这个位置
        if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
            ps.add(new Point(p1));
        }
        return ps;
    }

    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数
    public static void sort(ArrayList<Point> ps){
        ps.sort(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                //先获取o1的下一步的位置个数
                int count1 = next(o1).size();
                //再获取o2的下一步的位置个数
                int count2 = next(o2).size();
                if ( count1 < count2 ){
                    return -1;
                }else if ( count1 == count2){
                    return 0;
                }else {
                    return 1;
                }

            }
        });
    }
}

```



本次骑士周游算法算法 的教程出自韩顺平的数据结构与算法

[数据结构和算法教程](https://www.bilibili.com/video/BV1E4411H73v?p=190&spm_id_from=pageDriver&vd_source=027fde985896626031abccc06ce8b031)，哔哩哔哩详细教程
 在 189-194p.

最后，认识一下，我是小白。努力成为一名合格的程序员。期待与你的下次相遇



# 总结

**本次数据结构学习从2022.8.18开始，2022.9.15结束。中途休息两天，历时29天。学完啦**

接近7万个词，将近30万的字符。不敢相信，我真的坚持下来了！！！！

**下一次旅程：JＤＫ８新特新**

我来啦！！！！